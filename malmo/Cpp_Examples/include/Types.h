// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX_HOME_DAVEYBIGGERS_MALMO_PLATFORM_SCHEMAS_TYPES_H
#define CXX_HOME_DAVEYBIGGERS_MALMO_PLATFORM_SCHEMAS_TYPES_H

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace malmo
{
  namespace schemas
  {
    class Colour;
    class Facing;
    class ItemType;
    class BlockType;
    class BlockOrItem;
    class StoneTypes;
    class WoodTypes;
    class FlowerTypes;
    class MonsterEggTypes;
    class ShapeTypes;
    class HalfTypes;
    class EntityTypes;
    class NonLivingEntityTypes;
    class SpawnableTypes;
    class Variation;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

namespace malmo
{
  namespace schemas
  {
    class Colour: public ::xml_schema::string
    {
      public:
      enum value
      {
        WHITE,
        ORANGE,
        MAGENTA,
        LIGHT_BLUE,
        YELLOW,
        LIME,
        PINK,
        GRAY,
        SILVER,
        CYAN,
        PURPLE,
        BLUE,
        BROWN,
        GREEN,
        RED,
        BLACK
      };

      Colour (value v);

      Colour (const char* v);

      Colour (const ::std::string& v);

      Colour (const ::xml_schema::string& v);

      Colour (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Colour (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Colour (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Colour (const Colour& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual Colour*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Colour&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Colour_convert ();
      }

      protected:
      value
      _xsd_Colour_convert () const;

      public:
      static const char* const _xsd_Colour_literals_[16];
      static const value _xsd_Colour_indexes_[16];
    };

    class Facing: public ::xml_schema::string
    {
      public:
      enum value
      {
        DOWN,
        UP,
        NORTH,
        SOUTH,
        WEST,
        EAST,
        UP_X,
        DOWN_X,
        UP_Z,
        DOWN_Z
      };

      Facing (value v);

      Facing (const char* v);

      Facing (const ::std::string& v);

      Facing (const ::xml_schema::string& v);

      Facing (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Facing (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Facing (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Facing (const Facing& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual Facing*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Facing&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Facing_convert ();
      }

      protected:
      value
      _xsd_Facing_convert () const;

      public:
      static const char* const _xsd_Facing_literals_[10];
      static const value _xsd_Facing_indexes_[10];
    };

    class ItemType: public ::xml_schema::string
    {
      public:
      enum value
      {
        iron_shovel,
        iron_pickaxe,
        iron_axe,
        flint_and_steel,
        apple,
        bow,
        arrow,
        coal,
        diamond,
        iron_ingot,
        gold_ingot,
        iron_sword,
        wooden_sword,
        wooden_shovel,
        wooden_pickaxe,
        wooden_axe,
        stone_sword,
        stone_shovel,
        stone_pickaxe,
        stone_axe,
        diamond_sword,
        diamond_shovel,
        diamond_pickaxe,
        diamond_axe,
        stick,
        bowl,
        mushroom_stew,
        golden_sword,
        golden_shovel,
        golden_pickaxe,
        golden_axe,
        string,
        feather,
        gunpowder,
        wooden_hoe,
        stone_hoe,
        iron_hoe,
        diamond_hoe,
        golden_hoe,
        wheat_seeds,
        wheat,
        bread,
        leather_helmet,
        leather_chestplate,
        leather_leggings,
        leather_boots,
        chainmail_helmet,
        chainmail_chestplate,
        chainmail_leggings,
        chainmail_boots,
        iron_helmet,
        iron_chestplate,
        iron_leggings,
        iron_boots,
        diamond_helmet,
        diamond_chestplate,
        diamond_leggings,
        diamond_boots,
        golden_helmet,
        golden_chestplate,
        golden_leggings,
        golden_boots,
        flint,
        porkchop,
        cooked_porkchop,
        painting,
        golden_apple,
        sign,
        wooden_door,
        bucket,
        bucket1,
        water_bucket,
        lava_bucket,
        minecart,
        saddle,
        iron_door,
        redstone,
        snowball,
        boat,
        leather,
        milk_bucket,
        brick,
        clay_ball,
        reeds,
        paper,
        book,
        slime_ball,
        chest_minecart,
        furnace_minecart,
        egg,
        compass,
        fishing_rod,
        clock,
        glowstone_dust,
        fish,
        cooked_fish,
        dye,
        bone,
        sugar,
        cake,
        bed,
        repeater,
        cookie,
        filled_map,
        shears,
        melon,
        pumpkin_seeds,
        melon_seeds,
        beef,
        cooked_beef,
        chicken,
        cooked_chicken,
        rotten_flesh,
        ender_pearl,
        blaze_rod,
        ghast_tear,
        gold_nugget,
        nether_wart,
        potion,
        glass_bottle,
        spider_eye,
        fermented_spider_eye,
        blaze_powder,
        magma_cream,
        brewing_stand,
        cauldron,
        ender_eye,
        speckled_melon,
        spawn_egg,
        experience_bottle,
        fire_charge,
        writable_book,
        written_book,
        emerald,
        item_frame,
        flower_pot,
        carrot,
        potato,
        baked_potato,
        poisonous_potato,
        map,
        golden_carrot,
        skull,
        carrot_on_a_stick,
        nether_star,
        pumpkin_pie,
        fireworks,
        firework_charge,
        enchanted_book,
        comparator,
        netherbrick,
        quartz,
        tnt_minecart,
        hopper_minecart,
        prismarine_shard,
        prismarine_crystals,
        rabbit,
        cooked_rabbit,
        rabbit_stew,
        rabbit_foot,
        rabbit_hide,
        armor_stand,
        iron_horse_armor,
        golden_horse_armor,
        diamond_horse_armor,
        lead,
        name_tag,
        command_block_minecart,
        mutton,
        cooked_mutton,
        banner,
        spruce_door,
        birch_door,
        jungle_door,
        acacia_door,
        dark_oak_door,
        record_13,
        record_cat,
        record_blocks,
        record_chirp,
        record_far,
        record_mall,
        record_mellohi,
        record_stal,
        record_strad,
        record_ward,
        record_11,
        record_wait
      };

      ItemType (value v);

      ItemType (const char* v);

      ItemType (const ::std::string& v);

      ItemType (const ::xml_schema::string& v);

      ItemType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemType (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemType (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemType (const ItemType& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual ItemType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ItemType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ItemType_convert ();
      }

      protected:
      value
      _xsd_ItemType_convert () const;

      public:
      static const char* const _xsd_ItemType_literals_[188];
      static const value _xsd_ItemType_indexes_[188];
    };

    class BlockType: public ::xml_schema::string
    {
      public:
      enum value
      {
        air,
        stone,
        grass,
        dirt,
        cobblestone,
        planks,
        sapling,
        bedrock,
        flowing_water,
        water,
        flowing_lava,
        lava,
        sand,
        gravel,
        gold_ore,
        iron_ore,
        coal_ore,
        log,
        leaves,
        sponge,
        glass,
        lapis_ore,
        lapis_block,
        dispenser,
        sandstone,
        noteblock,
        bed,
        golden_rail,
        detector_rail,
        sticky_piston,
        web,
        tallgrass,
        deadbush,
        piston,
        piston_head,
        wool,
        piston_extension,
        yellow_flower,
        red_flower,
        brown_mushroom,
        red_mushroom,
        gold_block,
        iron_block,
        double_stone_slab,
        stone_slab,
        brick_block,
        tnt,
        bookshelf,
        mossy_cobblestone,
        obsidian,
        torch,
        fire,
        mob_spawner,
        oak_stairs,
        chest,
        redstone_wire,
        diamond_ore,
        diamond_block,
        crafting_table,
        wheat,
        farmland,
        furnace,
        lit_furnace,
        standing_sign,
        wooden_door,
        ladder,
        rail,
        stone_stairs,
        wall_sign,
        lever,
        stone_pressure_plate,
        iron_door,
        wooden_pressure_plate,
        redstone_ore,
        lit_redstone_ore,
        unlit_redstone_torch,
        redstone_torch,
        stone_button,
        snow_layer,
        ice,
        snow,
        cactus,
        clay,
        reeds,
        jukebox,
        fence,
        pumpkin,
        netherrack,
        soul_sand,
        glowstone,
        portal,
        lit_pumpkin,
        cake,
        unpowered_repeater,
        powered_repeater,
        stained_glass,
        trapdoor,
        monster_egg,
        stonebrick,
        brown_mushroom_block,
        red_mushroom_block,
        iron_bars,
        glass_pane,
        melon_block,
        pumpkin_stem,
        melon_stem,
        vine,
        fence_gate,
        brick_stairs,
        stone_brick_stairs,
        mycelium,
        waterlily,
        nether_brick,
        nether_brick_fence,
        nether_brick_stairs,
        nether_wart,
        enchanting_table,
        brewing_stand,
        cauldron,
        end_portal,
        end_portal_frame,
        end_stone,
        dragon_egg,
        redstone_lamp,
        lit_redstone_lamp,
        double_wooden_slab,
        wooden_slab,
        cocoa,
        sandstone_stairs,
        emerald_ore,
        ender_chest,
        tripwire_hook,
        tripwire,
        emerald_block,
        spruce_stairs,
        birch_stairs,
        jungle_stairs,
        command_block,
        beacon,
        cobblestone_wall,
        flower_pot,
        carrots,
        potatoes,
        wooden_button,
        skull,
        anvil,
        trapped_chest,
        light_weighted_pressure_plate,
        heavy_weighted_pressure_plate,
        unpowered_comparator,
        powered_comparator,
        daylight_detector,
        redstone_block,
        quartz_ore,
        hopper,
        quartz_block,
        quartz_stairs,
        activator_rail,
        dropper,
        stained_hardened_clay,
        stained_glass_pane,
        leaves2,
        log2,
        acacia_stairs,
        dark_oak_stairs,
        slime,
        barrier,
        iron_trapdoor,
        prismarine,
        sea_lantern,
        hay_block,
        carpet,
        hardened_clay,
        coal_block,
        packed_ice,
        double_plant,
        standing_banner,
        wall_banner,
        daylight_detector_inverted,
        red_sandstone,
        red_sandstone_stairs,
        double_stone_slab2,
        stone_slab2,
        spruce_fence_gate,
        birch_fence_gate,
        jungle_fence_gate,
        dark_oak_fence_gate,
        acacia_fence_gate,
        spruce_fence,
        birch_fence,
        jungle_fence,
        dark_oak_fence,
        acacia_fence,
        spruce_door,
        birch_door,
        jungle_door,
        acacia_door,
        dark_oak_door
      };

      BlockType (value v);

      BlockType (const char* v);

      BlockType (const ::std::string& v);

      BlockType (const ::xml_schema::string& v);

      BlockType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockType (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockType (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockType (const BlockType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual BlockType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockType&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_BlockType_convert ();
      }

      protected:
      value
      _xsd_BlockType_convert () const;

      public:
      static const char* const _xsd_BlockType_literals_[198];
      static const value _xsd_BlockType_indexes_[198];
    };

    class BlockOrItem: public ::xml_schema::string
    {
      public:
      enum value
      {
        air,
        stone,
        grass,
        dirt,
        cobblestone,
        planks,
        sapling,
        bedrock,
        flowing_water,
        water,
        flowing_lava,
        lava,
        sand,
        gravel,
        gold_ore,
        iron_ore,
        coal_ore,
        log,
        leaves,
        sponge,
        glass,
        lapis_ore,
        lapis_block,
        dispenser,
        sandstone,
        noteblock,
        bed,
        golden_rail,
        detector_rail,
        sticky_piston,
        web,
        tallgrass,
        deadbush,
        piston,
        piston_head,
        wool,
        piston_extension,
        yellow_flower,
        red_flower,
        brown_mushroom,
        red_mushroom,
        gold_block,
        iron_block,
        double_stone_slab,
        stone_slab,
        brick_block,
        tnt,
        bookshelf,
        mossy_cobblestone,
        obsidian,
        torch,
        fire,
        mob_spawner,
        oak_stairs,
        chest,
        redstone_wire,
        diamond_ore,
        diamond_block,
        crafting_table,
        wheat,
        farmland,
        furnace,
        lit_furnace,
        standing_sign,
        wooden_door,
        ladder,
        rail,
        stone_stairs,
        wall_sign,
        lever,
        stone_pressure_plate,
        iron_door,
        wooden_pressure_plate,
        redstone_ore,
        lit_redstone_ore,
        unlit_redstone_torch,
        redstone_torch,
        stone_button,
        snow_layer,
        ice,
        snow,
        cactus,
        clay,
        reeds,
        jukebox,
        fence,
        pumpkin,
        netherrack,
        soul_sand,
        glowstone,
        portal,
        lit_pumpkin,
        cake,
        unpowered_repeater,
        powered_repeater,
        stained_glass,
        trapdoor,
        monster_egg,
        stonebrick,
        brown_mushroom_block,
        red_mushroom_block,
        iron_bars,
        glass_pane,
        melon_block,
        pumpkin_stem,
        melon_stem,
        vine,
        fence_gate,
        brick_stairs,
        stone_brick_stairs,
        mycelium,
        waterlily,
        nether_brick,
        nether_brick_fence,
        nether_brick_stairs,
        nether_wart,
        enchanting_table,
        brewing_stand,
        cauldron,
        end_portal,
        end_portal_frame,
        end_stone,
        dragon_egg,
        redstone_lamp,
        lit_redstone_lamp,
        double_wooden_slab,
        wooden_slab,
        cocoa,
        sandstone_stairs,
        emerald_ore,
        ender_chest,
        tripwire_hook,
        tripwire,
        emerald_block,
        spruce_stairs,
        birch_stairs,
        jungle_stairs,
        command_block,
        beacon,
        cobblestone_wall,
        flower_pot,
        carrots,
        potatoes,
        wooden_button,
        skull,
        anvil,
        trapped_chest,
        light_weighted_pressure_plate,
        heavy_weighted_pressure_plate,
        unpowered_comparator,
        powered_comparator,
        daylight_detector,
        redstone_block,
        quartz_ore,
        hopper,
        quartz_block,
        quartz_stairs,
        activator_rail,
        dropper,
        stained_hardened_clay,
        stained_glass_pane,
        leaves2,
        log2,
        acacia_stairs,
        dark_oak_stairs,
        slime,
        barrier,
        iron_trapdoor,
        prismarine,
        sea_lantern,
        hay_block,
        carpet,
        hardened_clay,
        coal_block,
        packed_ice,
        double_plant,
        standing_banner,
        wall_banner,
        daylight_detector_inverted,
        red_sandstone,
        red_sandstone_stairs,
        double_stone_slab2,
        stone_slab2,
        spruce_fence_gate,
        birch_fence_gate,
        jungle_fence_gate,
        dark_oak_fence_gate,
        acacia_fence_gate,
        spruce_fence,
        birch_fence,
        jungle_fence,
        dark_oak_fence,
        acacia_fence,
        spruce_door,
        birch_door,
        jungle_door,
        acacia_door,
        dark_oak_door,
        iron_shovel,
        iron_pickaxe,
        iron_axe,
        flint_and_steel,
        apple,
        bow,
        arrow,
        coal,
        diamond,
        iron_ingot,
        gold_ingot,
        iron_sword,
        wooden_sword,
        wooden_shovel,
        wooden_pickaxe,
        wooden_axe,
        stone_sword,
        stone_shovel,
        stone_pickaxe,
        stone_axe,
        diamond_sword,
        diamond_shovel,
        diamond_pickaxe,
        diamond_axe,
        stick,
        bowl,
        mushroom_stew,
        golden_sword,
        golden_shovel,
        golden_pickaxe,
        golden_axe,
        string,
        feather,
        gunpowder,
        wooden_hoe,
        stone_hoe,
        iron_hoe,
        diamond_hoe,
        golden_hoe,
        wheat_seeds,
        bread,
        leather_helmet,
        leather_chestplate,
        leather_leggings,
        leather_boots,
        chainmail_helmet,
        chainmail_chestplate,
        chainmail_leggings,
        chainmail_boots,
        iron_helmet,
        iron_chestplate,
        iron_leggings,
        iron_boots,
        diamond_helmet,
        diamond_chestplate,
        diamond_leggings,
        diamond_boots,
        golden_helmet,
        golden_chestplate,
        golden_leggings,
        golden_boots,
        flint,
        porkchop,
        cooked_porkchop,
        painting,
        golden_apple,
        sign,
        bucket,
        water_bucket,
        lava_bucket,
        minecart,
        saddle,
        redstone,
        snowball,
        boat,
        leather,
        milk_bucket,
        brick,
        clay_ball,
        paper,
        book,
        slime_ball,
        chest_minecart,
        furnace_minecart,
        egg,
        compass,
        fishing_rod,
        clock,
        glowstone_dust,
        fish,
        cooked_fish,
        dye,
        bone,
        sugar,
        repeater,
        cookie,
        filled_map,
        shears,
        melon,
        pumpkin_seeds,
        melon_seeds,
        beef,
        cooked_beef,
        chicken,
        cooked_chicken,
        rotten_flesh,
        ender_pearl,
        blaze_rod,
        ghast_tear,
        gold_nugget,
        potion,
        glass_bottle,
        spider_eye,
        fermented_spider_eye,
        blaze_powder,
        magma_cream,
        ender_eye,
        speckled_melon,
        spawn_egg,
        experience_bottle,
        fire_charge,
        writable_book,
        written_book,
        emerald,
        item_frame,
        carrot,
        potato,
        baked_potato,
        poisonous_potato,
        map,
        golden_carrot,
        carrot_on_a_stick,
        nether_star,
        pumpkin_pie,
        fireworks,
        firework_charge,
        enchanted_book,
        comparator,
        netherbrick,
        quartz,
        tnt_minecart,
        hopper_minecart,
        prismarine_shard,
        prismarine_crystals,
        rabbit,
        cooked_rabbit,
        rabbit_stew,
        rabbit_foot,
        rabbit_hide,
        armor_stand,
        iron_horse_armor,
        golden_horse_armor,
        diamond_horse_armor,
        lead,
        name_tag,
        command_block_minecart,
        mutton,
        cooked_mutton,
        banner,
        record_13,
        record_cat,
        record_blocks,
        record_chirp,
        record_far,
        record_mall,
        record_mellohi,
        record_stal,
        record_strad,
        record_ward,
        record_11,
        record_wait
      };

      BlockOrItem (value v);

      BlockOrItem (const char* v);

      BlockOrItem (const ::std::string& v);

      BlockOrItem (const ::xml_schema::string& v);

      BlockOrItem (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      BlockOrItem (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      BlockOrItem (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      BlockOrItem (const BlockOrItem& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual BlockOrItem*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockOrItem&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_BlockOrItem_convert ();
      }

      protected:
      value
      _xsd_BlockOrItem_convert () const;

      public:
      static const char* const _xsd_BlockOrItem_literals_[369];
      static const value _xsd_BlockOrItem_indexes_[369];
    };

    class StoneTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        stone,
        granite,
        smooth_granite,
        diorite,
        smooth_diorite,
        andesite,
        smooth_andesite
      };

      StoneTypes (value v);

      StoneTypes (const char* v);

      StoneTypes (const ::std::string& v);

      StoneTypes (const ::xml_schema::string& v);

      StoneTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      StoneTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      StoneTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      StoneTypes (const StoneTypes& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual StoneTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StoneTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_StoneTypes_convert ();
      }

      protected:
      value
      _xsd_StoneTypes_convert () const;

      public:
      static const char* const _xsd_StoneTypes_literals_[7];
      static const value _xsd_StoneTypes_indexes_[7];
    };

    class WoodTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        oak,
        spruce,
        birch,
        jungle,
        acacia,
        dark_oak
      };

      WoodTypes (value v);

      WoodTypes (const char* v);

      WoodTypes (const ::std::string& v);

      WoodTypes (const ::xml_schema::string& v);

      WoodTypes (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      WoodTypes (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      WoodTypes (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      WoodTypes (const WoodTypes& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual WoodTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      WoodTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_WoodTypes_convert ();
      }

      protected:
      value
      _xsd_WoodTypes_convert () const;

      public:
      static const char* const _xsd_WoodTypes_literals_[6];
      static const value _xsd_WoodTypes_indexes_[6];
    };

    class FlowerTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        dandelion,
        poppy,
        blue_orchid,
        allium,
        houstonia,
        red_tulip,
        orange_tulip,
        white_tulip,
        pink_tulip,
        oxeye_daisy
      };

      FlowerTypes (value v);

      FlowerTypes (const char* v);

      FlowerTypes (const ::std::string& v);

      FlowerTypes (const ::xml_schema::string& v);

      FlowerTypes (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FlowerTypes (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FlowerTypes (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      FlowerTypes (const FlowerTypes& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual FlowerTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlowerTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_FlowerTypes_convert ();
      }

      protected:
      value
      _xsd_FlowerTypes_convert () const;

      public:
      static const char* const _xsd_FlowerTypes_literals_[10];
      static const value _xsd_FlowerTypes_indexes_[10];
    };

    class MonsterEggTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        cobblestone,
        stone_brick,
        mossy_brick,
        cracked_brick,
        chiseled_brick
      };

      MonsterEggTypes (value v);

      MonsterEggTypes (const char* v);

      MonsterEggTypes (const ::std::string& v);

      MonsterEggTypes (const ::xml_schema::string& v);

      MonsterEggTypes (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      MonsterEggTypes (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      MonsterEggTypes (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      MonsterEggTypes (const MonsterEggTypes& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual MonsterEggTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MonsterEggTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MonsterEggTypes_convert ();
      }

      protected:
      value
      _xsd_MonsterEggTypes_convert () const;

      public:
      static const char* const _xsd_MonsterEggTypes_literals_[5];
      static const value _xsd_MonsterEggTypes_indexes_[5];
    };

    class ShapeTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        north_south,
        east_west,
        north_east,
        north_west,
        south_east,
        south_west,
        ascending_east,
        ascending_west,
        ascending_north,
        ascending_south
      };

      ShapeTypes (value v);

      ShapeTypes (const char* v);

      ShapeTypes (const ::std::string& v);

      ShapeTypes (const ::xml_schema::string& v);

      ShapeTypes (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ShapeTypes (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ShapeTypes (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ShapeTypes (const ShapeTypes& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual ShapeTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ShapeTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ShapeTypes_convert ();
      }

      protected:
      value
      _xsd_ShapeTypes_convert () const;

      public:
      static const char* const _xsd_ShapeTypes_literals_[10];
      static const value _xsd_ShapeTypes_indexes_[10];
    };

    class HalfTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        top,
        bottom,
        head,
        foot,
        upper,
        lower
      };

      HalfTypes (value v);

      HalfTypes (const char* v);

      HalfTypes (const ::std::string& v);

      HalfTypes (const ::xml_schema::string& v);

      HalfTypes (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      HalfTypes (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      HalfTypes (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      HalfTypes (const HalfTypes& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual HalfTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HalfTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_HalfTypes_convert ();
      }

      protected:
      value
      _xsd_HalfTypes_convert () const;

      public:
      static const char* const _xsd_HalfTypes_literals_[6];
      static const value _xsd_HalfTypes_indexes_[6];
    };

    class EntityTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        Creeper,
        Skeleton,
        Spider,
        Giant,
        Zombie,
        Slime,
        Ghast,
        PigZombie,
        Enderman,
        CaveSpider,
        Silverfish,
        Blaze,
        LavaSlime,
        EnderDragon,
        WitherBoss,
        Bat,
        Witch,
        Endermite,
        Guardian,
        Pig,
        Sheep,
        Cow,
        Chicken,
        Squid,
        Wolf,
        MushroomCow,
        SnowMan,
        Ozelot,
        VillagerGolem,
        EntityHorse,
        Rabbit,
        Villager,
        EnderCrystal
      };

      EntityTypes (value v);

      EntityTypes (const char* v);

      EntityTypes (const ::std::string& v);

      EntityTypes (const ::xml_schema::string& v);

      EntityTypes (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      EntityTypes (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      EntityTypes (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      EntityTypes (const EntityTypes& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual EntityTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      EntityTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_EntityTypes_convert ();
      }

      protected:
      value
      _xsd_EntityTypes_convert () const;

      public:
      static const char* const _xsd_EntityTypes_literals_[33];
      static const value _xsd_EntityTypes_indexes_[33];
    };

    class NonLivingEntityTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        Minecart,
        Boat,
        ArmorStand,
        ItemFrame
      };

      NonLivingEntityTypes (value v);

      NonLivingEntityTypes (const char* v);

      NonLivingEntityTypes (const ::std::string& v);

      NonLivingEntityTypes (const ::xml_schema::string& v);

      NonLivingEntityTypes (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonLivingEntityTypes (const ::xercesc::DOMAttr& a,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonLivingEntityTypes (const ::std::string& s,
                            const ::xercesc::DOMElement* e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      NonLivingEntityTypes (const NonLivingEntityTypes& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual NonLivingEntityTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NonLivingEntityTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_NonLivingEntityTypes_convert ();
      }

      protected:
      value
      _xsd_NonLivingEntityTypes_convert () const;

      public:
      static const char* const _xsd_NonLivingEntityTypes_literals_[4];
      static const value _xsd_NonLivingEntityTypes_indexes_[4];
    };

    class SpawnableTypes: public ::xml_schema::string
    {
      public:
      enum value
      {
        Creeper,
        Skeleton,
        Spider,
        Giant,
        Zombie,
        Slime,
        Ghast,
        PigZombie,
        Enderman,
        CaveSpider,
        Silverfish,
        Blaze,
        LavaSlime,
        EnderDragon,
        WitherBoss,
        Bat,
        Witch,
        Endermite,
        Guardian,
        Pig,
        Sheep,
        Cow,
        Chicken,
        Squid,
        Wolf,
        MushroomCow,
        SnowMan,
        Ozelot,
        VillagerGolem,
        EntityHorse,
        Rabbit,
        Villager,
        EnderCrystal,
        Minecart,
        Boat,
        ArmorStand,
        ItemFrame
      };

      SpawnableTypes (value v);

      SpawnableTypes (const char* v);

      SpawnableTypes (const ::std::string& v);

      SpawnableTypes (const ::xml_schema::string& v);

      SpawnableTypes (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SpawnableTypes (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SpawnableTypes (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SpawnableTypes (const SpawnableTypes& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SpawnableTypes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SpawnableTypes&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SpawnableTypes_convert ();
      }

      protected:
      value
      _xsd_SpawnableTypes_convert () const;

      public:
      static const char* const _xsd_SpawnableTypes_literals_[37];
      static const value _xsd_SpawnableTypes_indexes_[37];
    };

    class Variation: public ::xml_schema::string
    {
      public:
      enum value
      {
        stone,
        granite,
        smooth_granite,
        diorite,
        smooth_diorite,
        andesite,
        smooth_andesite,
        oak,
        spruce,
        birch,
        jungle,
        acacia,
        dark_oak,
        dandelion,
        poppy,
        blue_orchid,
        allium,
        houstonia,
        red_tulip,
        orange_tulip,
        white_tulip,
        pink_tulip,
        oxeye_daisy,
        Creeper,
        Skeleton,
        Spider,
        Giant,
        Zombie,
        Slime,
        Ghast,
        PigZombie,
        Enderman,
        CaveSpider,
        Silverfish,
        Blaze,
        LavaSlime,
        EnderDragon,
        WitherBoss,
        Bat,
        Witch,
        Endermite,
        Guardian,
        Pig,
        Sheep,
        Cow,
        Chicken,
        Squid,
        Wolf,
        MushroomCow,
        SnowMan,
        Ozelot,
        VillagerGolem,
        EntityHorse,
        Rabbit,
        Villager,
        EnderCrystal,
        north_south,
        east_west,
        north_east,
        north_west,
        south_east,
        south_west,
        ascending_east,
        ascending_west,
        ascending_north,
        ascending_south,
        cobblestone,
        stone_brick,
        mossy_brick,
        cracked_brick,
        chiseled_brick,
        top,
        bottom,
        head,
        foot,
        upper,
        lower
      };

      Variation (value v);

      Variation (const char* v);

      Variation (const ::std::string& v);

      Variation (const ::xml_schema::string& v);

      Variation (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Variation (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Variation (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Variation (const Variation& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual Variation*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Variation&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Variation_convert ();
      }

      protected:
      value
      _xsd_Variation_convert () const;

      public:
      static const char* const _xsd_Variation_literals_[77];
      static const value _xsd_Variation_indexes_[77];
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace malmo
{
  namespace schemas
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace malmo
{
  namespace schemas
  {
    void
    operator<< (::xercesc::DOMElement&, const Colour&);

    void
    operator<< (::xercesc::DOMAttr&, const Colour&);

    void
    operator<< (::xml_schema::list_stream&,
                const Colour&);

    void
    operator<< (::xercesc::DOMElement&, const Facing&);

    void
    operator<< (::xercesc::DOMAttr&, const Facing&);

    void
    operator<< (::xml_schema::list_stream&,
                const Facing&);

    void
    operator<< (::xercesc::DOMElement&, const ItemType&);

    void
    operator<< (::xercesc::DOMAttr&, const ItemType&);

    void
    operator<< (::xml_schema::list_stream&,
                const ItemType&);

    void
    operator<< (::xercesc::DOMElement&, const BlockType&);

    void
    operator<< (::xercesc::DOMAttr&, const BlockType&);

    void
    operator<< (::xml_schema::list_stream&,
                const BlockType&);

    void
    operator<< (::xercesc::DOMElement&, const BlockOrItem&);

    void
    operator<< (::xercesc::DOMAttr&, const BlockOrItem&);

    void
    operator<< (::xml_schema::list_stream&,
                const BlockOrItem&);

    void
    operator<< (::xercesc::DOMElement&, const StoneTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const StoneTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const StoneTypes&);

    void
    operator<< (::xercesc::DOMElement&, const WoodTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const WoodTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const WoodTypes&);

    void
    operator<< (::xercesc::DOMElement&, const FlowerTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const FlowerTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const FlowerTypes&);

    void
    operator<< (::xercesc::DOMElement&, const MonsterEggTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const MonsterEggTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const MonsterEggTypes&);

    void
    operator<< (::xercesc::DOMElement&, const ShapeTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const ShapeTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const ShapeTypes&);

    void
    operator<< (::xercesc::DOMElement&, const HalfTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const HalfTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const HalfTypes&);

    void
    operator<< (::xercesc::DOMElement&, const EntityTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const EntityTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const EntityTypes&);

    void
    operator<< (::xercesc::DOMElement&, const NonLivingEntityTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const NonLivingEntityTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const NonLivingEntityTypes&);

    void
    operator<< (::xercesc::DOMElement&, const SpawnableTypes&);

    void
    operator<< (::xercesc::DOMAttr&, const SpawnableTypes&);

    void
    operator<< (::xml_schema::list_stream&,
                const SpawnableTypes&);

    void
    operator<< (::xercesc::DOMElement&, const Variation&);

    void
    operator<< (::xercesc::DOMAttr&, const Variation&);

    void
    operator<< (::xml_schema::list_stream&,
                const Variation&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_HOME_DAVEYBIGGERS_MALMO_PLATFORM_SCHEMAS_TYPES_H
