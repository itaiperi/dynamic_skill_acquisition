// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX_HOME_DAVEY_MALMO_PLATFORM_SCHEMAS_MISSION_H
#define CXX_HOME_DAVEY_MALMO_PLATFORM_SCHEMAS_MISSION_H

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace malmo
{
  namespace schemas
  {
    class InventoryObjectType;
    class GameMode;
    class Mission;
    class ModSettings;
    class ServerSection;
    class AgentSection;
    class About;
    class AgentStart;
    class ServerInitialConditions;
    class Time;
    class StartTime;
    class Weather;
    class slot;
    class quantity;
    class InventoryItem;
    class InventoryBlock;
    class AgentHandlers;
    class ServerHandlers;
    class MsPerTick;
    class Inventory;
    class AllowedMobs;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "Types.h"

#include "MissionHandlers.h"

namespace malmo
{
  namespace schemas
  {
    class InventoryObjectType: public ::xml_schema::type
    {
      public:
      // slot
      //
      typedef ::malmo::schemas::slot slot_type;
      typedef ::xsd::cxx::tree::traits< slot_type, char > slot_traits;

      const slot_type&
      slot () const;

      slot_type&
      slot ();

      void
      slot (const slot_type& x);

      void
      slot (::std::auto_ptr< slot_type > p);

      // type
      //
      typedef ::malmo::schemas::BlockOrItem type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::Variation variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::Colour colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // quantity
      //
      typedef ::malmo::schemas::quantity quantity_type;
      typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

      const quantity_type&
      quantity () const;

      quantity_type&
      quantity ();

      void
      quantity (const quantity_type& x);

      void
      quantity (::std::auto_ptr< quantity_type > p);

      static quantity_type
      quantity_default_value ();

      // Constructors.
      //
      InventoryObjectType (const slot_type&,
                           const type_type&);

      InventoryObjectType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      InventoryObjectType (const InventoryObjectType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual InventoryObjectType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InventoryObjectType&
      operator= (const InventoryObjectType& x);

      virtual 
      ~InventoryObjectType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< slot_type > slot_;
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
      ::xsd::cxx::tree::one< quantity_type > quantity_;
    };

    class GameMode: public ::xml_schema::string
    {
      public:
      enum value
      {
        Survival,
        Creative,
        Adventure,
        Spectator
      };

      GameMode (value v);

      GameMode (const char* v);

      GameMode (const ::std::string& v);

      GameMode (const ::xml_schema::string& v);

      GameMode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      GameMode (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      GameMode (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      GameMode (const GameMode& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual GameMode*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GameMode&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_GameMode_convert ();
      }

      protected:
      value
      _xsd_GameMode_convert () const;

      public:
      static const char* const _xsd_GameMode_literals_[4];
      static const value _xsd_GameMode_indexes_[4];
    };

    class Mission: public ::xml_schema::type
    {
      public:
      // About
      //
      typedef ::malmo::schemas::About About_type;
      typedef ::xsd::cxx::tree::traits< About_type, char > About_traits;

      const About_type&
      About () const;

      About_type&
      About ();

      void
      About (const About_type& x);

      void
      About (::std::auto_ptr< About_type > p);

      // ModSettings
      //
      typedef ::malmo::schemas::ModSettings ModSettings_type;
      typedef ::xsd::cxx::tree::optional< ModSettings_type > ModSettings_optional;
      typedef ::xsd::cxx::tree::traits< ModSettings_type, char > ModSettings_traits;

      const ModSettings_optional&
      ModSettings () const;

      ModSettings_optional&
      ModSettings ();

      void
      ModSettings (const ModSettings_type& x);

      void
      ModSettings (const ModSettings_optional& x);

      void
      ModSettings (::std::auto_ptr< ModSettings_type > p);

      // ServerSection
      //
      typedef ::malmo::schemas::ServerSection ServerSection_type;
      typedef ::xsd::cxx::tree::traits< ServerSection_type, char > ServerSection_traits;

      const ServerSection_type&
      ServerSection () const;

      ServerSection_type&
      ServerSection ();

      void
      ServerSection (const ServerSection_type& x);

      void
      ServerSection (::std::auto_ptr< ServerSection_type > p);

      // AgentSection
      //
      typedef ::malmo::schemas::AgentSection AgentSection_type;
      typedef ::xsd::cxx::tree::sequence< AgentSection_type > AgentSection_sequence;
      typedef AgentSection_sequence::iterator AgentSection_iterator;
      typedef AgentSection_sequence::const_iterator AgentSection_const_iterator;
      typedef ::xsd::cxx::tree::traits< AgentSection_type, char > AgentSection_traits;

      const AgentSection_sequence&
      AgentSection () const;

      AgentSection_sequence&
      AgentSection ();

      void
      AgentSection (const AgentSection_sequence& s);

      // SchemaVersion
      //
      typedef ::xml_schema::token SchemaVersion_type;
      typedef ::xsd::cxx::tree::optional< SchemaVersion_type > SchemaVersion_optional;
      typedef ::xsd::cxx::tree::traits< SchemaVersion_type, char > SchemaVersion_traits;

      const SchemaVersion_optional&
      SchemaVersion () const;

      SchemaVersion_optional&
      SchemaVersion ();

      void
      SchemaVersion (const SchemaVersion_type& x);

      void
      SchemaVersion (const SchemaVersion_optional& x);

      void
      SchemaVersion (::std::auto_ptr< SchemaVersion_type > p);

      // Constructors.
      //
      Mission (const About_type&,
               const ServerSection_type&);

      Mission (::std::auto_ptr< About_type >,
               ::std::auto_ptr< ServerSection_type >);

      Mission (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Mission (const Mission& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual Mission*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Mission&
      operator= (const Mission& x);

      virtual 
      ~Mission ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< About_type > About_;
      ModSettings_optional ModSettings_;
      ::xsd::cxx::tree::one< ServerSection_type > ServerSection_;
      AgentSection_sequence AgentSection_;
      SchemaVersion_optional SchemaVersion_;
    };

    class ModSettings: public ::xml_schema::type
    {
      public:
      // MsPerTick
      //
      typedef ::malmo::schemas::MsPerTick MsPerTick_type;
      typedef ::xsd::cxx::tree::optional< MsPerTick_type > MsPerTick_optional;
      typedef ::xsd::cxx::tree::traits< MsPerTick_type, char > MsPerTick_traits;

      const MsPerTick_optional&
      MsPerTick () const;

      MsPerTick_optional&
      MsPerTick ();

      void
      MsPerTick (const MsPerTick_type& x);

      void
      MsPerTick (const MsPerTick_optional& x);

      void
      MsPerTick (::std::auto_ptr< MsPerTick_type > p);

      // PrioritiseOffscreenRendering
      //
      typedef ::xml_schema::boolean PrioritiseOffscreenRendering_type;
      typedef ::xsd::cxx::tree::optional< PrioritiseOffscreenRendering_type > PrioritiseOffscreenRendering_optional;
      typedef ::xsd::cxx::tree::traits< PrioritiseOffscreenRendering_type, char > PrioritiseOffscreenRendering_traits;

      const PrioritiseOffscreenRendering_optional&
      PrioritiseOffscreenRendering () const;

      PrioritiseOffscreenRendering_optional&
      PrioritiseOffscreenRendering ();

      void
      PrioritiseOffscreenRendering (const PrioritiseOffscreenRendering_type& x);

      void
      PrioritiseOffscreenRendering (const PrioritiseOffscreenRendering_optional& x);

      // Constructors.
      //
      ModSettings ();

      ModSettings (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ModSettings (const ModSettings& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ModSettings*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ModSettings&
      operator= (const ModSettings& x);

      virtual 
      ~ModSettings ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      MsPerTick_optional MsPerTick_;
      PrioritiseOffscreenRendering_optional PrioritiseOffscreenRendering_;
    };

    class ServerSection: public ::xml_schema::type
    {
      public:
      // ServerInitialConditions
      //
      typedef ::malmo::schemas::ServerInitialConditions ServerInitialConditions_type;
      typedef ::xsd::cxx::tree::optional< ServerInitialConditions_type > ServerInitialConditions_optional;
      typedef ::xsd::cxx::tree::traits< ServerInitialConditions_type, char > ServerInitialConditions_traits;

      const ServerInitialConditions_optional&
      ServerInitialConditions () const;

      ServerInitialConditions_optional&
      ServerInitialConditions ();

      void
      ServerInitialConditions (const ServerInitialConditions_type& x);

      void
      ServerInitialConditions (const ServerInitialConditions_optional& x);

      void
      ServerInitialConditions (::std::auto_ptr< ServerInitialConditions_type > p);

      // ServerHandlers
      //
      typedef ::malmo::schemas::ServerHandlers ServerHandlers_type;
      typedef ::xsd::cxx::tree::traits< ServerHandlers_type, char > ServerHandlers_traits;

      const ServerHandlers_type&
      ServerHandlers () const;

      ServerHandlers_type&
      ServerHandlers ();

      void
      ServerHandlers (const ServerHandlers_type& x);

      void
      ServerHandlers (::std::auto_ptr< ServerHandlers_type > p);

      // Constructors.
      //
      ServerSection (const ServerHandlers_type&);

      ServerSection (::std::auto_ptr< ServerHandlers_type >);

      ServerSection (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ServerSection (const ServerSection& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ServerSection*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ServerSection&
      operator= (const ServerSection& x);

      virtual 
      ~ServerSection ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ServerInitialConditions_optional ServerInitialConditions_;
      ::xsd::cxx::tree::one< ServerHandlers_type > ServerHandlers_;
    };

    class AgentSection: public ::xml_schema::type
    {
      public:
      // Name
      //
      typedef ::xml_schema::string Name_type;
      typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

      const Name_type&
      Name () const;

      Name_type&
      Name ();

      void
      Name (const Name_type& x);

      void
      Name (::std::auto_ptr< Name_type > p);

      // AgentStart
      //
      typedef ::malmo::schemas::AgentStart AgentStart_type;
      typedef ::xsd::cxx::tree::traits< AgentStart_type, char > AgentStart_traits;

      const AgentStart_type&
      AgentStart () const;

      AgentStart_type&
      AgentStart ();

      void
      AgentStart (const AgentStart_type& x);

      void
      AgentStart (::std::auto_ptr< AgentStart_type > p);

      // AgentHandlers
      //
      typedef ::malmo::schemas::AgentHandlers AgentHandlers_type;
      typedef ::xsd::cxx::tree::traits< AgentHandlers_type, char > AgentHandlers_traits;

      const AgentHandlers_type&
      AgentHandlers () const;

      AgentHandlers_type&
      AgentHandlers ();

      void
      AgentHandlers (const AgentHandlers_type& x);

      void
      AgentHandlers (::std::auto_ptr< AgentHandlers_type > p);

      // mode
      //
      typedef ::malmo::schemas::GameMode mode_type;
      typedef ::xsd::cxx::tree::traits< mode_type, char > mode_traits;

      const mode_type&
      mode () const;

      mode_type&
      mode ();

      void
      mode (const mode_type& x);

      void
      mode (::std::auto_ptr< mode_type > p);

      static const mode_type&
      mode_default_value ();

      // Constructors.
      //
      AgentSection (const Name_type&,
                    const AgentStart_type&,
                    const AgentHandlers_type&);

      AgentSection (const Name_type&,
                    ::std::auto_ptr< AgentStart_type >,
                    ::std::auto_ptr< AgentHandlers_type >);

      AgentSection (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      AgentSection (const AgentSection& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual AgentSection*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentSection&
      operator= (const AgentSection& x);

      virtual 
      ~AgentSection ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Name_type > Name_;
      ::xsd::cxx::tree::one< AgentStart_type > AgentStart_;
      ::xsd::cxx::tree::one< AgentHandlers_type > AgentHandlers_;
      ::xsd::cxx::tree::one< mode_type > mode_;
      static const mode_type mode_default_value_;
    };

    class About: public ::xml_schema::type
    {
      public:
      // Summary
      //
      typedef ::xml_schema::string Summary_type;
      typedef ::xsd::cxx::tree::traits< Summary_type, char > Summary_traits;

      const Summary_type&
      Summary () const;

      Summary_type&
      Summary ();

      void
      Summary (const Summary_type& x);

      void
      Summary (::std::auto_ptr< Summary_type > p);

      // Description
      //
      typedef ::xml_schema::string Description_type;
      typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
      typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

      const Description_optional&
      Description () const;

      Description_optional&
      Description ();

      void
      Description (const Description_type& x);

      void
      Description (const Description_optional& x);

      void
      Description (::std::auto_ptr< Description_type > p);

      // Constructors.
      //
      About (const Summary_type&);

      About (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      About (const About& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual About*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      About&
      operator= (const About& x);

      virtual 
      ~About ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Summary_type > Summary_;
      Description_optional Description_;
    };

    class AgentStart: public ::xml_schema::type
    {
      public:
      // Placement
      //
      typedef ::malmo::schemas::PosAndDirection Placement_type;
      typedef ::xsd::cxx::tree::optional< Placement_type > Placement_optional;
      typedef ::xsd::cxx::tree::traits< Placement_type, char > Placement_traits;

      const Placement_optional&
      Placement () const;

      Placement_optional&
      Placement ();

      void
      Placement (const Placement_type& x);

      void
      Placement (const Placement_optional& x);

      void
      Placement (::std::auto_ptr< Placement_type > p);

      // Inventory
      //
      typedef ::malmo::schemas::Inventory Inventory_type;
      typedef ::xsd::cxx::tree::optional< Inventory_type > Inventory_optional;
      typedef ::xsd::cxx::tree::traits< Inventory_type, char > Inventory_traits;

      const Inventory_optional&
      Inventory () const;

      Inventory_optional&
      Inventory ();

      void
      Inventory (const Inventory_type& x);

      void
      Inventory (const Inventory_optional& x);

      void
      Inventory (::std::auto_ptr< Inventory_type > p);

      // Constructors.
      //
      AgentStart ();

      AgentStart (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      AgentStart (const AgentStart& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual AgentStart*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentStart&
      operator= (const AgentStart& x);

      virtual 
      ~AgentStart ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Placement_optional Placement_;
      Inventory_optional Inventory_;
    };

    class ServerInitialConditions: public ::xml_schema::type
    {
      public:
      // Time
      //
      typedef ::malmo::schemas::Time Time_type;
      typedef ::xsd::cxx::tree::optional< Time_type > Time_optional;
      typedef ::xsd::cxx::tree::traits< Time_type, char > Time_traits;

      const Time_optional&
      Time () const;

      Time_optional&
      Time ();

      void
      Time (const Time_type& x);

      void
      Time (const Time_optional& x);

      void
      Time (::std::auto_ptr< Time_type > p);

      // Weather
      //
      typedef ::malmo::schemas::Weather Weather_type;
      typedef ::xsd::cxx::tree::optional< Weather_type > Weather_optional;
      typedef ::xsd::cxx::tree::traits< Weather_type, char > Weather_traits;

      const Weather_optional&
      Weather () const;

      Weather_optional&
      Weather ();

      void
      Weather (const Weather_type& x);

      void
      Weather (const Weather_optional& x);

      void
      Weather (::std::auto_ptr< Weather_type > p);

      static const Weather_type&
      Weather_default_value ();

      // AllowSpawning
      //
      typedef ::xml_schema::boolean AllowSpawning_type;
      typedef ::xsd::cxx::tree::optional< AllowSpawning_type > AllowSpawning_optional;
      typedef ::xsd::cxx::tree::traits< AllowSpawning_type, char > AllowSpawning_traits;

      const AllowSpawning_optional&
      AllowSpawning () const;

      AllowSpawning_optional&
      AllowSpawning ();

      void
      AllowSpawning (const AllowSpawning_type& x);

      void
      AllowSpawning (const AllowSpawning_optional& x);

      static AllowSpawning_type
      AllowSpawning_default_value ();

      // AllowedMobs
      //
      typedef ::malmo::schemas::AllowedMobs AllowedMobs_type;
      typedef ::xsd::cxx::tree::optional< AllowedMobs_type > AllowedMobs_optional;
      typedef ::xsd::cxx::tree::traits< AllowedMobs_type, char > AllowedMobs_traits;

      const AllowedMobs_optional&
      AllowedMobs () const;

      AllowedMobs_optional&
      AllowedMobs ();

      void
      AllowedMobs (const AllowedMobs_type& x);

      void
      AllowedMobs (const AllowedMobs_optional& x);

      void
      AllowedMobs (::std::auto_ptr< AllowedMobs_type > p);

      // Constructors.
      //
      ServerInitialConditions ();

      ServerInitialConditions (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ServerInitialConditions (const ServerInitialConditions& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ServerInitialConditions*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ServerInitialConditions&
      operator= (const ServerInitialConditions& x);

      virtual 
      ~ServerInitialConditions ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Time_optional Time_;
      Weather_optional Weather_;
      static const Weather_type Weather_default_value_;
      AllowSpawning_optional AllowSpawning_;
      AllowedMobs_optional AllowedMobs_;
    };

    class Time: public ::xml_schema::type
    {
      public:
      // StartTime
      //
      typedef ::malmo::schemas::StartTime StartTime_type;
      typedef ::xsd::cxx::tree::optional< StartTime_type > StartTime_optional;
      typedef ::xsd::cxx::tree::traits< StartTime_type, char > StartTime_traits;

      const StartTime_optional&
      StartTime () const;

      StartTime_optional&
      StartTime ();

      void
      StartTime (const StartTime_type& x);

      void
      StartTime (const StartTime_optional& x);

      void
      StartTime (::std::auto_ptr< StartTime_type > p);

      // AllowPassageOfTime
      //
      typedef ::xml_schema::boolean AllowPassageOfTime_type;
      typedef ::xsd::cxx::tree::optional< AllowPassageOfTime_type > AllowPassageOfTime_optional;
      typedef ::xsd::cxx::tree::traits< AllowPassageOfTime_type, char > AllowPassageOfTime_traits;

      const AllowPassageOfTime_optional&
      AllowPassageOfTime () const;

      AllowPassageOfTime_optional&
      AllowPassageOfTime ();

      void
      AllowPassageOfTime (const AllowPassageOfTime_type& x);

      void
      AllowPassageOfTime (const AllowPassageOfTime_optional& x);

      static AllowPassageOfTime_type
      AllowPassageOfTime_default_value ();

      // Constructors.
      //
      Time ();

      Time (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      Time (const Time& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual Time*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Time&
      operator= (const Time& x);

      virtual 
      ~Time ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      StartTime_optional StartTime_;
      AllowPassageOfTime_optional AllowPassageOfTime_;
    };

    class StartTime: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      StartTime (const ::xml_schema::int_&);

      StartTime (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      StartTime (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      StartTime (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      StartTime (const StartTime& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual StartTime*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~StartTime ();
    };

    class Weather: public ::xml_schema::string
    {
      public:
      enum value
      {
        normal,
        clear,
        rain,
        thunder
      };

      Weather (value v);

      Weather (const char* v);

      Weather (const ::std::string& v);

      Weather (const ::xml_schema::string& v);

      Weather (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Weather (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Weather (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Weather (const Weather& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual Weather*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Weather&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Weather_convert ();
      }

      protected:
      value
      _xsd_Weather_convert () const;

      public:
      static const char* const _xsd_Weather_literals_[4];
      static const value _xsd_Weather_indexes_[4];
    };

    class slot: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      slot (const ::xml_schema::int_&);

      slot (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      slot (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      slot (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      slot (const slot& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual slot*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~slot ();
    };

    class quantity: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      quantity (const ::xml_schema::int_&);

      quantity (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      quantity (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      quantity (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      quantity (const quantity& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual quantity*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~quantity ();
    };

    class InventoryItem: public ::malmo::schemas::InventoryObjectType
    {
      public:
      // Constructors.
      //
      InventoryItem (const slot_type&,
                     const type_type&);

      InventoryItem (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      InventoryItem (const InventoryItem& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual InventoryItem*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~InventoryItem ();
    };

    class InventoryBlock: public ::malmo::schemas::InventoryObjectType
    {
      public:
      // Constructors.
      //
      InventoryBlock (const slot_type&,
                      const type_type&);

      InventoryBlock (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      InventoryBlock (const InventoryBlock& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual InventoryBlock*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~InventoryBlock ();
    };

    class AgentHandlers: public ::xml_schema::type
    {
      public:
      // ObservationFromRecentCommands
      //
      typedef ::malmo::schemas::ObservationFromRecentCommands ObservationFromRecentCommands_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromRecentCommands_type > ObservationFromRecentCommands_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromRecentCommands_type, char > ObservationFromRecentCommands_traits;

      const ObservationFromRecentCommands_optional&
      ObservationFromRecentCommands () const;

      ObservationFromRecentCommands_optional&
      ObservationFromRecentCommands ();

      void
      ObservationFromRecentCommands (const ObservationFromRecentCommands_type& x);

      void
      ObservationFromRecentCommands (const ObservationFromRecentCommands_optional& x);

      void
      ObservationFromRecentCommands (::std::auto_ptr< ObservationFromRecentCommands_type > p);

      // ObservationFromHotBar
      //
      typedef ::malmo::schemas::ObservationFromHotBar ObservationFromHotBar_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromHotBar_type > ObservationFromHotBar_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromHotBar_type, char > ObservationFromHotBar_traits;

      const ObservationFromHotBar_optional&
      ObservationFromHotBar () const;

      ObservationFromHotBar_optional&
      ObservationFromHotBar ();

      void
      ObservationFromHotBar (const ObservationFromHotBar_type& x);

      void
      ObservationFromHotBar (const ObservationFromHotBar_optional& x);

      void
      ObservationFromHotBar (::std::auto_ptr< ObservationFromHotBar_type > p);

      // ObservationFromFullStats
      //
      typedef ::malmo::schemas::ObservationFromFullStats ObservationFromFullStats_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromFullStats_type > ObservationFromFullStats_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromFullStats_type, char > ObservationFromFullStats_traits;

      const ObservationFromFullStats_optional&
      ObservationFromFullStats () const;

      ObservationFromFullStats_optional&
      ObservationFromFullStats ();

      void
      ObservationFromFullStats (const ObservationFromFullStats_type& x);

      void
      ObservationFromFullStats (const ObservationFromFullStats_optional& x);

      void
      ObservationFromFullStats (::std::auto_ptr< ObservationFromFullStats_type > p);

      // ObservationFromFullInventory
      //
      typedef ::malmo::schemas::ObservationFromFullInventory ObservationFromFullInventory_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromFullInventory_type > ObservationFromFullInventory_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromFullInventory_type, char > ObservationFromFullInventory_traits;

      const ObservationFromFullInventory_optional&
      ObservationFromFullInventory () const;

      ObservationFromFullInventory_optional&
      ObservationFromFullInventory ();

      void
      ObservationFromFullInventory (const ObservationFromFullInventory_type& x);

      void
      ObservationFromFullInventory (const ObservationFromFullInventory_optional& x);

      void
      ObservationFromFullInventory (::std::auto_ptr< ObservationFromFullInventory_type > p);

      // ObservationFromSubgoalPositionList
      //
      typedef ::malmo::schemas::ObservationFromSubgoalPositionList ObservationFromSubgoalPositionList_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromSubgoalPositionList_type > ObservationFromSubgoalPositionList_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromSubgoalPositionList_type, char > ObservationFromSubgoalPositionList_traits;

      const ObservationFromSubgoalPositionList_optional&
      ObservationFromSubgoalPositionList () const;

      ObservationFromSubgoalPositionList_optional&
      ObservationFromSubgoalPositionList ();

      void
      ObservationFromSubgoalPositionList (const ObservationFromSubgoalPositionList_type& x);

      void
      ObservationFromSubgoalPositionList (const ObservationFromSubgoalPositionList_optional& x);

      void
      ObservationFromSubgoalPositionList (::std::auto_ptr< ObservationFromSubgoalPositionList_type > p);

      // ObservationFromGrid
      //
      typedef ::malmo::schemas::ObservationFromGrid ObservationFromGrid_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromGrid_type > ObservationFromGrid_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromGrid_type, char > ObservationFromGrid_traits;

      const ObservationFromGrid_optional&
      ObservationFromGrid () const;

      ObservationFromGrid_optional&
      ObservationFromGrid ();

      void
      ObservationFromGrid (const ObservationFromGrid_type& x);

      void
      ObservationFromGrid (const ObservationFromGrid_optional& x);

      void
      ObservationFromGrid (::std::auto_ptr< ObservationFromGrid_type > p);

      // ObservationFromDistance
      //
      typedef ::malmo::schemas::ObservationFromDistance ObservationFromDistance_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromDistance_type > ObservationFromDistance_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromDistance_type, char > ObservationFromDistance_traits;

      const ObservationFromDistance_optional&
      ObservationFromDistance () const;

      ObservationFromDistance_optional&
      ObservationFromDistance ();

      void
      ObservationFromDistance (const ObservationFromDistance_type& x);

      void
      ObservationFromDistance (const ObservationFromDistance_optional& x);

      void
      ObservationFromDistance (::std::auto_ptr< ObservationFromDistance_type > p);

      // ObservationFromDiscreteCell
      //
      typedef ::malmo::schemas::ObservationFromDiscreteCell ObservationFromDiscreteCell_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromDiscreteCell_type > ObservationFromDiscreteCell_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromDiscreteCell_type, char > ObservationFromDiscreteCell_traits;

      const ObservationFromDiscreteCell_optional&
      ObservationFromDiscreteCell () const;

      ObservationFromDiscreteCell_optional&
      ObservationFromDiscreteCell ();

      void
      ObservationFromDiscreteCell (const ObservationFromDiscreteCell_type& x);

      void
      ObservationFromDiscreteCell (const ObservationFromDiscreteCell_optional& x);

      void
      ObservationFromDiscreteCell (::std::auto_ptr< ObservationFromDiscreteCell_type > p);

      // ObservationFromChat
      //
      typedef ::malmo::schemas::ObservationFromChat ObservationFromChat_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromChat_type > ObservationFromChat_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromChat_type, char > ObservationFromChat_traits;

      const ObservationFromChat_optional&
      ObservationFromChat () const;

      ObservationFromChat_optional&
      ObservationFromChat ();

      void
      ObservationFromChat (const ObservationFromChat_type& x);

      void
      ObservationFromChat (const ObservationFromChat_optional& x);

      void
      ObservationFromChat (::std::auto_ptr< ObservationFromChat_type > p);

      // ObservationFromNearbyEntities
      //
      typedef ::malmo::schemas::ObservationFromNearbyEntities ObservationFromNearbyEntities_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromNearbyEntities_type > ObservationFromNearbyEntities_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromNearbyEntities_type, char > ObservationFromNearbyEntities_traits;

      const ObservationFromNearbyEntities_optional&
      ObservationFromNearbyEntities () const;

      ObservationFromNearbyEntities_optional&
      ObservationFromNearbyEntities ();

      void
      ObservationFromNearbyEntities (const ObservationFromNearbyEntities_type& x);

      void
      ObservationFromNearbyEntities (const ObservationFromNearbyEntities_optional& x);

      void
      ObservationFromNearbyEntities (::std::auto_ptr< ObservationFromNearbyEntities_type > p);

      // ObservationFromRay
      //
      typedef ::malmo::schemas::ObservationFromRay ObservationFromRay_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromRay_type > ObservationFromRay_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromRay_type, char > ObservationFromRay_traits;

      const ObservationFromRay_optional&
      ObservationFromRay () const;

      ObservationFromRay_optional&
      ObservationFromRay ();

      void
      ObservationFromRay (const ObservationFromRay_type& x);

      void
      ObservationFromRay (const ObservationFromRay_optional& x);

      void
      ObservationFromRay (::std::auto_ptr< ObservationFromRay_type > p);

      // ObservationFromTurnScheduler
      //
      typedef ::malmo::schemas::ObservationFromTurnScheduler ObservationFromTurnScheduler_type;
      typedef ::xsd::cxx::tree::optional< ObservationFromTurnScheduler_type > ObservationFromTurnScheduler_optional;
      typedef ::xsd::cxx::tree::traits< ObservationFromTurnScheduler_type, char > ObservationFromTurnScheduler_traits;

      const ObservationFromTurnScheduler_optional&
      ObservationFromTurnScheduler () const;

      ObservationFromTurnScheduler_optional&
      ObservationFromTurnScheduler ();

      void
      ObservationFromTurnScheduler (const ObservationFromTurnScheduler_type& x);

      void
      ObservationFromTurnScheduler (const ObservationFromTurnScheduler_optional& x);

      void
      ObservationFromTurnScheduler (::std::auto_ptr< ObservationFromTurnScheduler_type > p);

      // VideoProducer
      //
      typedef ::malmo::schemas::VideoProducer VideoProducer_type;
      typedef ::xsd::cxx::tree::optional< VideoProducer_type > VideoProducer_optional;
      typedef ::xsd::cxx::tree::traits< VideoProducer_type, char > VideoProducer_traits;

      const VideoProducer_optional&
      VideoProducer () const;

      VideoProducer_optional&
      VideoProducer ();

      void
      VideoProducer (const VideoProducer_type& x);

      void
      VideoProducer (const VideoProducer_optional& x);

      void
      VideoProducer (::std::auto_ptr< VideoProducer_type > p);

      // RewardForTouchingBlockType
      //
      typedef ::malmo::schemas::RewardForTouchingBlockType RewardForTouchingBlockType_type;
      typedef ::xsd::cxx::tree::optional< RewardForTouchingBlockType_type > RewardForTouchingBlockType_optional;
      typedef ::xsd::cxx::tree::traits< RewardForTouchingBlockType_type, char > RewardForTouchingBlockType_traits;

      const RewardForTouchingBlockType_optional&
      RewardForTouchingBlockType () const;

      RewardForTouchingBlockType_optional&
      RewardForTouchingBlockType ();

      void
      RewardForTouchingBlockType (const RewardForTouchingBlockType_type& x);

      void
      RewardForTouchingBlockType (const RewardForTouchingBlockType_optional& x);

      void
      RewardForTouchingBlockType (::std::auto_ptr< RewardForTouchingBlockType_type > p);

      // RewardForSendingCommand
      //
      typedef ::malmo::schemas::RewardForSendingCommand RewardForSendingCommand_type;
      typedef ::xsd::cxx::tree::optional< RewardForSendingCommand_type > RewardForSendingCommand_optional;
      typedef ::xsd::cxx::tree::traits< RewardForSendingCommand_type, char > RewardForSendingCommand_traits;

      const RewardForSendingCommand_optional&
      RewardForSendingCommand () const;

      RewardForSendingCommand_optional&
      RewardForSendingCommand ();

      void
      RewardForSendingCommand (const RewardForSendingCommand_type& x);

      void
      RewardForSendingCommand (const RewardForSendingCommand_optional& x);

      void
      RewardForSendingCommand (::std::auto_ptr< RewardForSendingCommand_type > p);

      // RewardForSendingMatchingChatMessage
      //
      typedef ::malmo::schemas::RewardForSendingMatchingChatMessage RewardForSendingMatchingChatMessage_type;
      typedef ::xsd::cxx::tree::optional< RewardForSendingMatchingChatMessage_type > RewardForSendingMatchingChatMessage_optional;
      typedef ::xsd::cxx::tree::traits< RewardForSendingMatchingChatMessage_type, char > RewardForSendingMatchingChatMessage_traits;

      const RewardForSendingMatchingChatMessage_optional&
      RewardForSendingMatchingChatMessage () const;

      RewardForSendingMatchingChatMessage_optional&
      RewardForSendingMatchingChatMessage ();

      void
      RewardForSendingMatchingChatMessage (const RewardForSendingMatchingChatMessage_type& x);

      void
      RewardForSendingMatchingChatMessage (const RewardForSendingMatchingChatMessage_optional& x);

      void
      RewardForSendingMatchingChatMessage (::std::auto_ptr< RewardForSendingMatchingChatMessage_type > p);

      // RewardForCollectingItem
      //
      typedef ::malmo::schemas::RewardForCollectingItem RewardForCollectingItem_type;
      typedef ::xsd::cxx::tree::optional< RewardForCollectingItem_type > RewardForCollectingItem_optional;
      typedef ::xsd::cxx::tree::traits< RewardForCollectingItem_type, char > RewardForCollectingItem_traits;

      const RewardForCollectingItem_optional&
      RewardForCollectingItem () const;

      RewardForCollectingItem_optional&
      RewardForCollectingItem ();

      void
      RewardForCollectingItem (const RewardForCollectingItem_type& x);

      void
      RewardForCollectingItem (const RewardForCollectingItem_optional& x);

      void
      RewardForCollectingItem (::std::auto_ptr< RewardForCollectingItem_type > p);

      // RewardForDiscardingItem
      //
      typedef ::malmo::schemas::RewardForDiscardingItem RewardForDiscardingItem_type;
      typedef ::xsd::cxx::tree::optional< RewardForDiscardingItem_type > RewardForDiscardingItem_optional;
      typedef ::xsd::cxx::tree::traits< RewardForDiscardingItem_type, char > RewardForDiscardingItem_traits;

      const RewardForDiscardingItem_optional&
      RewardForDiscardingItem () const;

      RewardForDiscardingItem_optional&
      RewardForDiscardingItem ();

      void
      RewardForDiscardingItem (const RewardForDiscardingItem_type& x);

      void
      RewardForDiscardingItem (const RewardForDiscardingItem_optional& x);

      void
      RewardForDiscardingItem (::std::auto_ptr< RewardForDiscardingItem_type > p);

      // RewardForReachingPosition
      //
      typedef ::malmo::schemas::RewardForReachingPosition RewardForReachingPosition_type;
      typedef ::xsd::cxx::tree::optional< RewardForReachingPosition_type > RewardForReachingPosition_optional;
      typedef ::xsd::cxx::tree::traits< RewardForReachingPosition_type, char > RewardForReachingPosition_traits;

      const RewardForReachingPosition_optional&
      RewardForReachingPosition () const;

      RewardForReachingPosition_optional&
      RewardForReachingPosition ();

      void
      RewardForReachingPosition (const RewardForReachingPosition_type& x);

      void
      RewardForReachingPosition (const RewardForReachingPosition_optional& x);

      void
      RewardForReachingPosition (::std::auto_ptr< RewardForReachingPosition_type > p);

      // RewardForMissionEnd
      //
      typedef ::malmo::schemas::RewardForMissionEnd RewardForMissionEnd_type;
      typedef ::xsd::cxx::tree::optional< RewardForMissionEnd_type > RewardForMissionEnd_optional;
      typedef ::xsd::cxx::tree::traits< RewardForMissionEnd_type, char > RewardForMissionEnd_traits;

      const RewardForMissionEnd_optional&
      RewardForMissionEnd () const;

      RewardForMissionEnd_optional&
      RewardForMissionEnd ();

      void
      RewardForMissionEnd (const RewardForMissionEnd_type& x);

      void
      RewardForMissionEnd (const RewardForMissionEnd_optional& x);

      void
      RewardForMissionEnd (::std::auto_ptr< RewardForMissionEnd_type > p);

      // RewardForStructureCopying
      //
      typedef ::malmo::schemas::RewardForStructureCopying RewardForStructureCopying_type;
      typedef ::xsd::cxx::tree::optional< RewardForStructureCopying_type > RewardForStructureCopying_optional;
      typedef ::xsd::cxx::tree::traits< RewardForStructureCopying_type, char > RewardForStructureCopying_traits;

      const RewardForStructureCopying_optional&
      RewardForStructureCopying () const;

      RewardForStructureCopying_optional&
      RewardForStructureCopying ();

      void
      RewardForStructureCopying (const RewardForStructureCopying_type& x);

      void
      RewardForStructureCopying (const RewardForStructureCopying_optional& x);

      void
      RewardForStructureCopying (::std::auto_ptr< RewardForStructureCopying_type > p);

      // RewardForTimeTaken
      //
      typedef ::malmo::schemas::RewardForTimeTaken RewardForTimeTaken_type;
      typedef ::xsd::cxx::tree::optional< RewardForTimeTaken_type > RewardForTimeTaken_optional;
      typedef ::xsd::cxx::tree::traits< RewardForTimeTaken_type, char > RewardForTimeTaken_traits;

      const RewardForTimeTaken_optional&
      RewardForTimeTaken () const;

      RewardForTimeTaken_optional&
      RewardForTimeTaken ();

      void
      RewardForTimeTaken (const RewardForTimeTaken_type& x);

      void
      RewardForTimeTaken (const RewardForTimeTaken_optional& x);

      void
      RewardForTimeTaken (::std::auto_ptr< RewardForTimeTaken_type > p);

      // RewardForCatchingMob
      //
      typedef ::malmo::schemas::RewardForCatchingMob RewardForCatchingMob_type;
      typedef ::xsd::cxx::tree::optional< RewardForCatchingMob_type > RewardForCatchingMob_optional;
      typedef ::xsd::cxx::tree::traits< RewardForCatchingMob_type, char > RewardForCatchingMob_traits;

      const RewardForCatchingMob_optional&
      RewardForCatchingMob () const;

      RewardForCatchingMob_optional&
      RewardForCatchingMob ();

      void
      RewardForCatchingMob (const RewardForCatchingMob_type& x);

      void
      RewardForCatchingMob (const RewardForCatchingMob_optional& x);

      void
      RewardForCatchingMob (::std::auto_ptr< RewardForCatchingMob_type > p);

      // RewardForDamagingEntity
      //
      typedef ::malmo::schemas::RewardForDamagingEntity RewardForDamagingEntity_type;
      typedef ::xsd::cxx::tree::optional< RewardForDamagingEntity_type > RewardForDamagingEntity_optional;
      typedef ::xsd::cxx::tree::traits< RewardForDamagingEntity_type, char > RewardForDamagingEntity_traits;

      const RewardForDamagingEntity_optional&
      RewardForDamagingEntity () const;

      RewardForDamagingEntity_optional&
      RewardForDamagingEntity ();

      void
      RewardForDamagingEntity (const RewardForDamagingEntity_type& x);

      void
      RewardForDamagingEntity (const RewardForDamagingEntity_optional& x);

      void
      RewardForDamagingEntity (::std::auto_ptr< RewardForDamagingEntity_type > p);

      // ContinuousMovementCommands
      //
      typedef ::malmo::schemas::ContinuousMovementCommands ContinuousMovementCommands_type;
      typedef ::xsd::cxx::tree::optional< ContinuousMovementCommands_type > ContinuousMovementCommands_optional;
      typedef ::xsd::cxx::tree::traits< ContinuousMovementCommands_type, char > ContinuousMovementCommands_traits;

      const ContinuousMovementCommands_optional&
      ContinuousMovementCommands () const;

      ContinuousMovementCommands_optional&
      ContinuousMovementCommands ();

      void
      ContinuousMovementCommands (const ContinuousMovementCommands_type& x);

      void
      ContinuousMovementCommands (const ContinuousMovementCommands_optional& x);

      void
      ContinuousMovementCommands (::std::auto_ptr< ContinuousMovementCommands_type > p);

      // AbsoluteMovementCommands
      //
      typedef ::malmo::schemas::AbsoluteMovementCommands AbsoluteMovementCommands_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteMovementCommands_type > AbsoluteMovementCommands_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteMovementCommands_type, char > AbsoluteMovementCommands_traits;

      const AbsoluteMovementCommands_optional&
      AbsoluteMovementCommands () const;

      AbsoluteMovementCommands_optional&
      AbsoluteMovementCommands ();

      void
      AbsoluteMovementCommands (const AbsoluteMovementCommands_type& x);

      void
      AbsoluteMovementCommands (const AbsoluteMovementCommands_optional& x);

      void
      AbsoluteMovementCommands (::std::auto_ptr< AbsoluteMovementCommands_type > p);

      // DiscreteMovementCommands
      //
      typedef ::malmo::schemas::DiscreteMovementCommands DiscreteMovementCommands_type;
      typedef ::xsd::cxx::tree::optional< DiscreteMovementCommands_type > DiscreteMovementCommands_optional;
      typedef ::xsd::cxx::tree::traits< DiscreteMovementCommands_type, char > DiscreteMovementCommands_traits;

      const DiscreteMovementCommands_optional&
      DiscreteMovementCommands () const;

      DiscreteMovementCommands_optional&
      DiscreteMovementCommands ();

      void
      DiscreteMovementCommands (const DiscreteMovementCommands_type& x);

      void
      DiscreteMovementCommands (const DiscreteMovementCommands_optional& x);

      void
      DiscreteMovementCommands (::std::auto_ptr< DiscreteMovementCommands_type > p);

      // InventoryCommands
      //
      typedef ::malmo::schemas::InventoryCommands InventoryCommands_type;
      typedef ::xsd::cxx::tree::optional< InventoryCommands_type > InventoryCommands_optional;
      typedef ::xsd::cxx::tree::traits< InventoryCommands_type, char > InventoryCommands_traits;

      const InventoryCommands_optional&
      InventoryCommands () const;

      InventoryCommands_optional&
      InventoryCommands ();

      void
      InventoryCommands (const InventoryCommands_type& x);

      void
      InventoryCommands (const InventoryCommands_optional& x);

      void
      InventoryCommands (::std::auto_ptr< InventoryCommands_type > p);

      // ChatCommands
      //
      typedef ::malmo::schemas::ChatCommands ChatCommands_type;
      typedef ::xsd::cxx::tree::optional< ChatCommands_type > ChatCommands_optional;
      typedef ::xsd::cxx::tree::traits< ChatCommands_type, char > ChatCommands_traits;

      const ChatCommands_optional&
      ChatCommands () const;

      ChatCommands_optional&
      ChatCommands ();

      void
      ChatCommands (const ChatCommands_type& x);

      void
      ChatCommands (const ChatCommands_optional& x);

      void
      ChatCommands (::std::auto_ptr< ChatCommands_type > p);

      // SimpleCraftCommands
      //
      typedef ::malmo::schemas::SimpleCraftCommands SimpleCraftCommands_type;
      typedef ::xsd::cxx::tree::optional< SimpleCraftCommands_type > SimpleCraftCommands_optional;
      typedef ::xsd::cxx::tree::traits< SimpleCraftCommands_type, char > SimpleCraftCommands_traits;

      const SimpleCraftCommands_optional&
      SimpleCraftCommands () const;

      SimpleCraftCommands_optional&
      SimpleCraftCommands ();

      void
      SimpleCraftCommands (const SimpleCraftCommands_type& x);

      void
      SimpleCraftCommands (const SimpleCraftCommands_optional& x);

      void
      SimpleCraftCommands (::std::auto_ptr< SimpleCraftCommands_type > p);

      // MissionQuitCommands
      //
      typedef ::malmo::schemas::MissionQuitCommands MissionQuitCommands_type;
      typedef ::xsd::cxx::tree::optional< MissionQuitCommands_type > MissionQuitCommands_optional;
      typedef ::xsd::cxx::tree::traits< MissionQuitCommands_type, char > MissionQuitCommands_traits;

      const MissionQuitCommands_optional&
      MissionQuitCommands () const;

      MissionQuitCommands_optional&
      MissionQuitCommands ();

      void
      MissionQuitCommands (const MissionQuitCommands_type& x);

      void
      MissionQuitCommands (const MissionQuitCommands_optional& x);

      void
      MissionQuitCommands (::std::auto_ptr< MissionQuitCommands_type > p);

      // TurnBasedCommands
      //
      typedef ::malmo::schemas::TurnBasedCommands TurnBasedCommands_type;
      typedef ::xsd::cxx::tree::optional< TurnBasedCommands_type > TurnBasedCommands_optional;
      typedef ::xsd::cxx::tree::traits< TurnBasedCommands_type, char > TurnBasedCommands_traits;

      const TurnBasedCommands_optional&
      TurnBasedCommands () const;

      TurnBasedCommands_optional&
      TurnBasedCommands ();

      void
      TurnBasedCommands (const TurnBasedCommands_type& x);

      void
      TurnBasedCommands (const TurnBasedCommands_optional& x);

      void
      TurnBasedCommands (::std::auto_ptr< TurnBasedCommands_type > p);

      // AgentQuitFromTimeUp
      //
      typedef ::malmo::schemas::AgentQuitFromTimeUp AgentQuitFromTimeUp_type;
      typedef ::xsd::cxx::tree::optional< AgentQuitFromTimeUp_type > AgentQuitFromTimeUp_optional;
      typedef ::xsd::cxx::tree::traits< AgentQuitFromTimeUp_type, char > AgentQuitFromTimeUp_traits;

      const AgentQuitFromTimeUp_optional&
      AgentQuitFromTimeUp () const;

      AgentQuitFromTimeUp_optional&
      AgentQuitFromTimeUp ();

      void
      AgentQuitFromTimeUp (const AgentQuitFromTimeUp_type& x);

      void
      AgentQuitFromTimeUp (const AgentQuitFromTimeUp_optional& x);

      void
      AgentQuitFromTimeUp (::std::auto_ptr< AgentQuitFromTimeUp_type > p);

      // AgentQuitFromReachingPosition
      //
      typedef ::malmo::schemas::AgentQuitFromReachingPosition AgentQuitFromReachingPosition_type;
      typedef ::xsd::cxx::tree::optional< AgentQuitFromReachingPosition_type > AgentQuitFromReachingPosition_optional;
      typedef ::xsd::cxx::tree::traits< AgentQuitFromReachingPosition_type, char > AgentQuitFromReachingPosition_traits;

      const AgentQuitFromReachingPosition_optional&
      AgentQuitFromReachingPosition () const;

      AgentQuitFromReachingPosition_optional&
      AgentQuitFromReachingPosition ();

      void
      AgentQuitFromReachingPosition (const AgentQuitFromReachingPosition_type& x);

      void
      AgentQuitFromReachingPosition (const AgentQuitFromReachingPosition_optional& x);

      void
      AgentQuitFromReachingPosition (::std::auto_ptr< AgentQuitFromReachingPosition_type > p);

      // AgentQuitFromTouchingBlockType
      //
      typedef ::malmo::schemas::AgentQuitFromTouchingBlockType AgentQuitFromTouchingBlockType_type;
      typedef ::xsd::cxx::tree::optional< AgentQuitFromTouchingBlockType_type > AgentQuitFromTouchingBlockType_optional;
      typedef ::xsd::cxx::tree::traits< AgentQuitFromTouchingBlockType_type, char > AgentQuitFromTouchingBlockType_traits;

      const AgentQuitFromTouchingBlockType_optional&
      AgentQuitFromTouchingBlockType () const;

      AgentQuitFromTouchingBlockType_optional&
      AgentQuitFromTouchingBlockType ();

      void
      AgentQuitFromTouchingBlockType (const AgentQuitFromTouchingBlockType_type& x);

      void
      AgentQuitFromTouchingBlockType (const AgentQuitFromTouchingBlockType_optional& x);

      void
      AgentQuitFromTouchingBlockType (::std::auto_ptr< AgentQuitFromTouchingBlockType_type > p);

      // AgentQuitFromCollectingItem
      //
      typedef ::malmo::schemas::AgentQuitFromCollectingItem AgentQuitFromCollectingItem_type;
      typedef ::xsd::cxx::tree::optional< AgentQuitFromCollectingItem_type > AgentQuitFromCollectingItem_optional;
      typedef ::xsd::cxx::tree::traits< AgentQuitFromCollectingItem_type, char > AgentQuitFromCollectingItem_traits;

      const AgentQuitFromCollectingItem_optional&
      AgentQuitFromCollectingItem () const;

      AgentQuitFromCollectingItem_optional&
      AgentQuitFromCollectingItem ();

      void
      AgentQuitFromCollectingItem (const AgentQuitFromCollectingItem_type& x);

      void
      AgentQuitFromCollectingItem (const AgentQuitFromCollectingItem_optional& x);

      void
      AgentQuitFromCollectingItem (::std::auto_ptr< AgentQuitFromCollectingItem_type > p);

      // AgentQuitFromReachingCommandQuota
      //
      typedef ::malmo::schemas::AgentQuitFromReachingCommandQuota AgentQuitFromReachingCommandQuota_type;
      typedef ::xsd::cxx::tree::optional< AgentQuitFromReachingCommandQuota_type > AgentQuitFromReachingCommandQuota_optional;
      typedef ::xsd::cxx::tree::traits< AgentQuitFromReachingCommandQuota_type, char > AgentQuitFromReachingCommandQuota_traits;

      const AgentQuitFromReachingCommandQuota_optional&
      AgentQuitFromReachingCommandQuota () const;

      AgentQuitFromReachingCommandQuota_optional&
      AgentQuitFromReachingCommandQuota ();

      void
      AgentQuitFromReachingCommandQuota (const AgentQuitFromReachingCommandQuota_type& x);

      void
      AgentQuitFromReachingCommandQuota (const AgentQuitFromReachingCommandQuota_optional& x);

      void
      AgentQuitFromReachingCommandQuota (::std::auto_ptr< AgentQuitFromReachingCommandQuota_type > p);

      // AgentQuitFromCatchingMob
      //
      typedef ::malmo::schemas::AgentQuitFromCatchingMob AgentQuitFromCatchingMob_type;
      typedef ::xsd::cxx::tree::optional< AgentQuitFromCatchingMob_type > AgentQuitFromCatchingMob_optional;
      typedef ::xsd::cxx::tree::traits< AgentQuitFromCatchingMob_type, char > AgentQuitFromCatchingMob_traits;

      const AgentQuitFromCatchingMob_optional&
      AgentQuitFromCatchingMob () const;

      AgentQuitFromCatchingMob_optional&
      AgentQuitFromCatchingMob ();

      void
      AgentQuitFromCatchingMob (const AgentQuitFromCatchingMob_type& x);

      void
      AgentQuitFromCatchingMob (const AgentQuitFromCatchingMob_optional& x);

      void
      AgentQuitFromCatchingMob (::std::auto_ptr< AgentQuitFromCatchingMob_type > p);

      // Constructors.
      //
      AgentHandlers ();

      AgentHandlers (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      AgentHandlers (const AgentHandlers& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual AgentHandlers*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentHandlers&
      operator= (const AgentHandlers& x);

      virtual 
      ~AgentHandlers ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ObservationFromRecentCommands_optional ObservationFromRecentCommands_;
      ObservationFromHotBar_optional ObservationFromHotBar_;
      ObservationFromFullStats_optional ObservationFromFullStats_;
      ObservationFromFullInventory_optional ObservationFromFullInventory_;
      ObservationFromSubgoalPositionList_optional ObservationFromSubgoalPositionList_;
      ObservationFromGrid_optional ObservationFromGrid_;
      ObservationFromDistance_optional ObservationFromDistance_;
      ObservationFromDiscreteCell_optional ObservationFromDiscreteCell_;
      ObservationFromChat_optional ObservationFromChat_;
      ObservationFromNearbyEntities_optional ObservationFromNearbyEntities_;
      ObservationFromRay_optional ObservationFromRay_;
      ObservationFromTurnScheduler_optional ObservationFromTurnScheduler_;
      VideoProducer_optional VideoProducer_;
      RewardForTouchingBlockType_optional RewardForTouchingBlockType_;
      RewardForSendingCommand_optional RewardForSendingCommand_;
      RewardForSendingMatchingChatMessage_optional RewardForSendingMatchingChatMessage_;
      RewardForCollectingItem_optional RewardForCollectingItem_;
      RewardForDiscardingItem_optional RewardForDiscardingItem_;
      RewardForReachingPosition_optional RewardForReachingPosition_;
      RewardForMissionEnd_optional RewardForMissionEnd_;
      RewardForStructureCopying_optional RewardForStructureCopying_;
      RewardForTimeTaken_optional RewardForTimeTaken_;
      RewardForCatchingMob_optional RewardForCatchingMob_;
      RewardForDamagingEntity_optional RewardForDamagingEntity_;
      ContinuousMovementCommands_optional ContinuousMovementCommands_;
      AbsoluteMovementCommands_optional AbsoluteMovementCommands_;
      DiscreteMovementCommands_optional DiscreteMovementCommands_;
      InventoryCommands_optional InventoryCommands_;
      ChatCommands_optional ChatCommands_;
      SimpleCraftCommands_optional SimpleCraftCommands_;
      MissionQuitCommands_optional MissionQuitCommands_;
      TurnBasedCommands_optional TurnBasedCommands_;
      AgentQuitFromTimeUp_optional AgentQuitFromTimeUp_;
      AgentQuitFromReachingPosition_optional AgentQuitFromReachingPosition_;
      AgentQuitFromTouchingBlockType_optional AgentQuitFromTouchingBlockType_;
      AgentQuitFromCollectingItem_optional AgentQuitFromCollectingItem_;
      AgentQuitFromReachingCommandQuota_optional AgentQuitFromReachingCommandQuota_;
      AgentQuitFromCatchingMob_optional AgentQuitFromCatchingMob_;
    };

    class ServerHandlers: public ::xml_schema::type
    {
      public:
      // FlatWorldGenerator
      //
      typedef ::malmo::schemas::FlatWorldGenerator FlatWorldGenerator_type;
      typedef ::xsd::cxx::tree::optional< FlatWorldGenerator_type > FlatWorldGenerator_optional;
      typedef ::xsd::cxx::tree::traits< FlatWorldGenerator_type, char > FlatWorldGenerator_traits;

      const FlatWorldGenerator_optional&
      FlatWorldGenerator () const;

      FlatWorldGenerator_optional&
      FlatWorldGenerator ();

      void
      FlatWorldGenerator (const FlatWorldGenerator_type& x);

      void
      FlatWorldGenerator (const FlatWorldGenerator_optional& x);

      void
      FlatWorldGenerator (::std::auto_ptr< FlatWorldGenerator_type > p);

      // FileWorldGenerator
      //
      typedef ::malmo::schemas::FileWorldGenerator FileWorldGenerator_type;
      typedef ::xsd::cxx::tree::optional< FileWorldGenerator_type > FileWorldGenerator_optional;
      typedef ::xsd::cxx::tree::traits< FileWorldGenerator_type, char > FileWorldGenerator_traits;

      const FileWorldGenerator_optional&
      FileWorldGenerator () const;

      FileWorldGenerator_optional&
      FileWorldGenerator ();

      void
      FileWorldGenerator (const FileWorldGenerator_type& x);

      void
      FileWorldGenerator (const FileWorldGenerator_optional& x);

      void
      FileWorldGenerator (::std::auto_ptr< FileWorldGenerator_type > p);

      // DefaultWorldGenerator
      //
      typedef ::malmo::schemas::DefaultWorldGenerator DefaultWorldGenerator_type;
      typedef ::xsd::cxx::tree::optional< DefaultWorldGenerator_type > DefaultWorldGenerator_optional;
      typedef ::xsd::cxx::tree::traits< DefaultWorldGenerator_type, char > DefaultWorldGenerator_traits;

      const DefaultWorldGenerator_optional&
      DefaultWorldGenerator () const;

      DefaultWorldGenerator_optional&
      DefaultWorldGenerator ();

      void
      DefaultWorldGenerator (const DefaultWorldGenerator_type& x);

      void
      DefaultWorldGenerator (const DefaultWorldGenerator_optional& x);

      void
      DefaultWorldGenerator (::std::auto_ptr< DefaultWorldGenerator_type > p);

      // DrawingDecorator
      //
      typedef ::malmo::schemas::DrawingDecorator DrawingDecorator_type;
      typedef ::xsd::cxx::tree::sequence< DrawingDecorator_type > DrawingDecorator_sequence;
      typedef DrawingDecorator_sequence::iterator DrawingDecorator_iterator;
      typedef DrawingDecorator_sequence::const_iterator DrawingDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< DrawingDecorator_type, char > DrawingDecorator_traits;

      const DrawingDecorator_sequence&
      DrawingDecorator () const;

      DrawingDecorator_sequence&
      DrawingDecorator ();

      void
      DrawingDecorator (const DrawingDecorator_sequence& s);

      // AnimationDecorator
      //
      typedef ::malmo::schemas::AnimationDecorator AnimationDecorator_type;
      typedef ::xsd::cxx::tree::sequence< AnimationDecorator_type > AnimationDecorator_sequence;
      typedef AnimationDecorator_sequence::iterator AnimationDecorator_iterator;
      typedef AnimationDecorator_sequence::const_iterator AnimationDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< AnimationDecorator_type, char > AnimationDecorator_traits;

      const AnimationDecorator_sequence&
      AnimationDecorator () const;

      AnimationDecorator_sequence&
      AnimationDecorator ();

      void
      AnimationDecorator (const AnimationDecorator_sequence& s);

      // MazeDecorator
      //
      typedef ::malmo::schemas::MazeDecorator MazeDecorator_type;
      typedef ::xsd::cxx::tree::sequence< MazeDecorator_type > MazeDecorator_sequence;
      typedef MazeDecorator_sequence::iterator MazeDecorator_iterator;
      typedef MazeDecorator_sequence::const_iterator MazeDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< MazeDecorator_type, char > MazeDecorator_traits;

      const MazeDecorator_sequence&
      MazeDecorator () const;

      MazeDecorator_sequence&
      MazeDecorator ();

      void
      MazeDecorator (const MazeDecorator_sequence& s);

      // ClassroomDecorator
      //
      typedef ::malmo::schemas::ClassroomDecorator ClassroomDecorator_type;
      typedef ::xsd::cxx::tree::sequence< ClassroomDecorator_type > ClassroomDecorator_sequence;
      typedef ClassroomDecorator_sequence::iterator ClassroomDecorator_iterator;
      typedef ClassroomDecorator_sequence::const_iterator ClassroomDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< ClassroomDecorator_type, char > ClassroomDecorator_traits;

      const ClassroomDecorator_sequence&
      ClassroomDecorator () const;

      ClassroomDecorator_sequence&
      ClassroomDecorator ();

      void
      ClassroomDecorator (const ClassroomDecorator_sequence& s);

      // SnakeDecorator
      //
      typedef ::malmo::schemas::SnakeDecorator SnakeDecorator_type;
      typedef ::xsd::cxx::tree::sequence< SnakeDecorator_type > SnakeDecorator_sequence;
      typedef SnakeDecorator_sequence::iterator SnakeDecorator_iterator;
      typedef SnakeDecorator_sequence::const_iterator SnakeDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< SnakeDecorator_type, char > SnakeDecorator_traits;

      const SnakeDecorator_sequence&
      SnakeDecorator () const;

      SnakeDecorator_sequence&
      SnakeDecorator ();

      void
      SnakeDecorator (const SnakeDecorator_sequence& s);

      // MovingTargetDecorator
      //
      typedef ::malmo::schemas::MovingTargetDecorator MovingTargetDecorator_type;
      typedef ::xsd::cxx::tree::sequence< MovingTargetDecorator_type > MovingTargetDecorator_sequence;
      typedef MovingTargetDecorator_sequence::iterator MovingTargetDecorator_iterator;
      typedef MovingTargetDecorator_sequence::const_iterator MovingTargetDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< MovingTargetDecorator_type, char > MovingTargetDecorator_traits;

      const MovingTargetDecorator_sequence&
      MovingTargetDecorator () const;

      MovingTargetDecorator_sequence&
      MovingTargetDecorator ();

      void
      MovingTargetDecorator (const MovingTargetDecorator_sequence& s);

      // BuildBattleDecorator
      //
      typedef ::malmo::schemas::BuildBattleDecorator BuildBattleDecorator_type;
      typedef ::xsd::cxx::tree::sequence< BuildBattleDecorator_type > BuildBattleDecorator_sequence;
      typedef BuildBattleDecorator_sequence::iterator BuildBattleDecorator_iterator;
      typedef BuildBattleDecorator_sequence::const_iterator BuildBattleDecorator_const_iterator;
      typedef ::xsd::cxx::tree::traits< BuildBattleDecorator_type, char > BuildBattleDecorator_traits;

      const BuildBattleDecorator_sequence&
      BuildBattleDecorator () const;

      BuildBattleDecorator_sequence&
      BuildBattleDecorator ();

      void
      BuildBattleDecorator (const BuildBattleDecorator_sequence& s);

      // ServerQuitFromTimeUp
      //
      typedef ::malmo::schemas::ServerQuitFromTimeUp ServerQuitFromTimeUp_type;
      typedef ::xsd::cxx::tree::sequence< ServerQuitFromTimeUp_type > ServerQuitFromTimeUp_sequence;
      typedef ServerQuitFromTimeUp_sequence::iterator ServerQuitFromTimeUp_iterator;
      typedef ServerQuitFromTimeUp_sequence::const_iterator ServerQuitFromTimeUp_const_iterator;
      typedef ::xsd::cxx::tree::traits< ServerQuitFromTimeUp_type, char > ServerQuitFromTimeUp_traits;

      const ServerQuitFromTimeUp_sequence&
      ServerQuitFromTimeUp () const;

      ServerQuitFromTimeUp_sequence&
      ServerQuitFromTimeUp ();

      void
      ServerQuitFromTimeUp (const ServerQuitFromTimeUp_sequence& s);

      // ServerQuitWhenAnyAgentFinishes
      //
      typedef ::malmo::schemas::ServerQuitWhenAnyAgentFinishes ServerQuitWhenAnyAgentFinishes_type;
      typedef ::xsd::cxx::tree::sequence< ServerQuitWhenAnyAgentFinishes_type > ServerQuitWhenAnyAgentFinishes_sequence;
      typedef ServerQuitWhenAnyAgentFinishes_sequence::iterator ServerQuitWhenAnyAgentFinishes_iterator;
      typedef ServerQuitWhenAnyAgentFinishes_sequence::const_iterator ServerQuitWhenAnyAgentFinishes_const_iterator;
      typedef ::xsd::cxx::tree::traits< ServerQuitWhenAnyAgentFinishes_type, char > ServerQuitWhenAnyAgentFinishes_traits;

      const ServerQuitWhenAnyAgentFinishes_sequence&
      ServerQuitWhenAnyAgentFinishes () const;

      ServerQuitWhenAnyAgentFinishes_sequence&
      ServerQuitWhenAnyAgentFinishes ();

      void
      ServerQuitWhenAnyAgentFinishes (const ServerQuitWhenAnyAgentFinishes_sequence& s);

      // Constructors.
      //
      ServerHandlers ();

      ServerHandlers (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      ServerHandlers (const ServerHandlers& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual ServerHandlers*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ServerHandlers&
      operator= (const ServerHandlers& x);

      virtual 
      ~ServerHandlers ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      FlatWorldGenerator_optional FlatWorldGenerator_;
      FileWorldGenerator_optional FileWorldGenerator_;
      DefaultWorldGenerator_optional DefaultWorldGenerator_;
      DrawingDecorator_sequence DrawingDecorator_;
      AnimationDecorator_sequence AnimationDecorator_;
      MazeDecorator_sequence MazeDecorator_;
      ClassroomDecorator_sequence ClassroomDecorator_;
      SnakeDecorator_sequence SnakeDecorator_;
      MovingTargetDecorator_sequence MovingTargetDecorator_;
      BuildBattleDecorator_sequence BuildBattleDecorator_;
      ServerQuitFromTimeUp_sequence ServerQuitFromTimeUp_;
      ServerQuitWhenAnyAgentFinishes_sequence ServerQuitWhenAnyAgentFinishes_;
    };

    class MsPerTick: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      MsPerTick (const ::xml_schema::int_&);

      MsPerTick (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      MsPerTick (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      MsPerTick (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      MsPerTick (const MsPerTick& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual MsPerTick*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~MsPerTick ();
    };

    class Inventory: public ::xml_schema::type
    {
      public:
      // InventoryObject
      //
      typedef ::malmo::schemas::InventoryObjectType InventoryObject_type;
      typedef ::xsd::cxx::tree::sequence< InventoryObject_type > InventoryObject_sequence;
      typedef InventoryObject_sequence::iterator InventoryObject_iterator;
      typedef InventoryObject_sequence::const_iterator InventoryObject_const_iterator;
      typedef ::xsd::cxx::tree::traits< InventoryObject_type, char > InventoryObject_traits;

      const InventoryObject_sequence&
      InventoryObject () const;

      InventoryObject_sequence&
      InventoryObject ();

      void
      InventoryObject (const InventoryObject_sequence& s);

      // Constructors.
      //
      Inventory ();

      Inventory (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Inventory (const Inventory& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual Inventory*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Inventory&
      operator= (const Inventory& x);

      virtual 
      ~Inventory ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      InventoryObject_sequence InventoryObject_;
    };

    class AllowedMobs: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::EntityTypes, char >
    {
      public:
      AllowedMobs ();

      AllowedMobs (size_type n, const ::malmo::schemas::EntityTypes& x);

      template < typename I >
      AllowedMobs (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::EntityTypes, char > (begin, end, this)
      {
      }

      AllowedMobs (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      AllowedMobs (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      AllowedMobs (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      AllowedMobs (const AllowedMobs& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual AllowedMobs*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~AllowedMobs ();
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace malmo
{
  namespace schemas
  {
    // Parse a URI or a local file.
    //

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (const ::std::string& uri,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (const ::std::string& uri,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (const ::std::string& uri,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse std::istream.
    //

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::std::istream& is,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::std::istream& is,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::std::istream& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::std::istream& is,
              const ::std::string& id,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::std::istream& is,
              const ::std::string& id,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::InputSource.
    //

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::xercesc::InputSource& is,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::xercesc::InputSource& is,
              ::xml_schema::error_handler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::xercesc::InputSource& is,
              ::xercesc::DOMErrorHandler& eh,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    // Parse xercesc::DOMDocument.
    //

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (const ::xercesc::DOMDocument& d,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());

    ::std::auto_ptr< ::malmo::schemas::Mission >
    Mission_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
              ::xml_schema::flags f = 0,
              const ::xml_schema::properties& p = ::xml_schema::properties ());
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace malmo
{
  namespace schemas
  {
    // Serialize to std::ostream.
    //

    void
    Mission_ (::std::ostream& os,
              const ::malmo::schemas::Mission& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

    void
    Mission_ (::std::ostream& os,
              const ::malmo::schemas::Mission& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

    void
    Mission_ (::std::ostream& os,
              const ::malmo::schemas::Mission& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

    // Serialize to xercesc::XMLFormatTarget.
    //

    void
    Mission_ (::xercesc::XMLFormatTarget& ft,
              const ::malmo::schemas::Mission& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

    void
    Mission_ (::xercesc::XMLFormatTarget& ft,
              const ::malmo::schemas::Mission& x, 
              ::xml_schema::error_handler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

    void
    Mission_ (::xercesc::XMLFormatTarget& ft,
              const ::malmo::schemas::Mission& x, 
              ::xercesc::DOMErrorHandler& eh,
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              const ::std::string& e = "UTF-8",
              ::xml_schema::flags f = 0);

    // Serialize to an existing xercesc::DOMDocument.
    //

    void
    Mission_ (::xercesc::DOMDocument& d,
              const ::malmo::schemas::Mission& x,
              ::xml_schema::flags f = 0);

    // Serialize to a new xercesc::DOMDocument.
    //

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
    Mission_ (const ::malmo::schemas::Mission& x, 
              const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
              ::xml_schema::flags f = 0);

    void
    operator<< (::xercesc::DOMElement&, const InventoryObjectType&);

    void
    operator<< (::xercesc::DOMElement&, const GameMode&);

    void
    operator<< (::xercesc::DOMAttr&, const GameMode&);

    void
    operator<< (::xml_schema::list_stream&,
                const GameMode&);

    void
    operator<< (::xercesc::DOMElement&, const Mission&);

    void
    operator<< (::xercesc::DOMElement&, const ModSettings&);

    void
    operator<< (::xercesc::DOMElement&, const ServerSection&);

    void
    operator<< (::xercesc::DOMElement&, const AgentSection&);

    void
    operator<< (::xercesc::DOMElement&, const About&);

    void
    operator<< (::xercesc::DOMElement&, const AgentStart&);

    void
    operator<< (::xercesc::DOMElement&, const ServerInitialConditions&);

    void
    operator<< (::xercesc::DOMElement&, const Time&);

    void
    operator<< (::xercesc::DOMElement&, const StartTime&);

    void
    operator<< (::xercesc::DOMAttr&, const StartTime&);

    void
    operator<< (::xml_schema::list_stream&,
                const StartTime&);

    void
    operator<< (::xercesc::DOMElement&, const Weather&);

    void
    operator<< (::xercesc::DOMAttr&, const Weather&);

    void
    operator<< (::xml_schema::list_stream&,
                const Weather&);

    void
    operator<< (::xercesc::DOMElement&, const slot&);

    void
    operator<< (::xercesc::DOMAttr&, const slot&);

    void
    operator<< (::xml_schema::list_stream&,
                const slot&);

    void
    operator<< (::xercesc::DOMElement&, const quantity&);

    void
    operator<< (::xercesc::DOMAttr&, const quantity&);

    void
    operator<< (::xml_schema::list_stream&,
                const quantity&);

    void
    operator<< (::xercesc::DOMElement&, const InventoryItem&);

    void
    operator<< (::xercesc::DOMElement&, const InventoryBlock&);

    void
    operator<< (::xercesc::DOMElement&, const AgentHandlers&);

    void
    operator<< (::xercesc::DOMElement&, const ServerHandlers&);

    void
    operator<< (::xercesc::DOMElement&, const MsPerTick&);

    void
    operator<< (::xercesc::DOMAttr&, const MsPerTick&);

    void
    operator<< (::xml_schema::list_stream&,
                const MsPerTick&);

    void
    operator<< (::xercesc::DOMElement&, const Inventory&);

    void
    operator<< (::xercesc::DOMElement&, const AllowedMobs&);

    void
    operator<< (::xercesc::DOMAttr&, const AllowedMobs&);

    void
    operator<< (::xml_schema::list_stream&,
                const AllowedMobs&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_HOME_DAVEY_MALMO_PLATFORM_SCHEMAS_MISSION_H
