// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CXX_HOME_DAVEY_MALMO_PLATFORM_PY2_SCHEMAS_MISSION_HANDLERS_H
#define CXX_HOME_DAVEY_MALMO_PLATFORM_PY2_SCHEMAS_MISSION_HANDLERS_H

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::no_type_info< char > no_type_info;
  typedef ::xsd::cxx::tree::not_derived< char > not_derived;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
namespace malmo
{
  namespace schemas
  {
    class Pos;
    class PosAndDirection;
    class BlockList;
    class ItemList;
    class BlockOrItemList;
    class ColourList;
    class VariantList;
    class MazeBlock;
    class MazeTerminus;
    class SnakeBlock;
    class DrawObjectType;
    class DrawBlockBasedObjectType;
    class DrawBlock;
    class DrawItem;
    class ContainedObjectType;
    class DrawContainer;
    class DrawEntity;
    class DrawCuboid;
    class DrawSphere;
    class DrawLine;
    class PaletteEnum;
    class HorizontalObstacles;
    class VerticalObstacles;
    class BuildingSize;
    class ZeroToOne;
    class NonNegative;
    class HexColour;
    class MobWithColour;
    class ContinuousMovementCommand;
    class AbsoluteMovementCommand;
    class DiscreteMovementCommand;
    class InventoryCommand;
    class SimpleCraftCommand;
    class ChatCommand;
    class MissionQuitCommand;
    class Command;
    class CommandList;
    class CommandListModifier;
    class NamedPoint;
    class GridDefinition;
    class RangeDefinition;
    class Dimension;
    class PointWithReward;
    class MobWithReward;
    class BlockSpec;
    class BlockOrItemSpec;
    class BlockSpecWithRewardAndBehaviour;
    class BlockOrItemSpecWithReward;
    class Behaviour;
    class ChatMatchSpec;
    class ItemSpec;
    class MissionEndRewardCase;
    class RewardDensityForBuildAndBreak;
    class UnnamedGridDefinition;
    class RewardDensityForTimeTaken;
    class MobWithDescription;
    class MobWithDescriptionAndReward;
    class PointWithToleranceAndDescription;
    class BlockSpecWithDescription;
    class BlockOrItemSpecWithDescription;
    class MobList;
    class CommandQuota;
    class yaw;
    class pitch;
    class FlatWorldGenerator;
    class DefaultWorldGenerator;
    class FileWorldGenerator;
    class MovingTargetDecorator;
    class SnakeDecorator;
    class MazeDecorator;
    class DrawingDecorator;
    class ClassroomDecorator;
    class AnimationDecorator;
    class BuildBattleDecorator;
    class ServerQuitFromTimeUp;
    class ServerQuitWhenAnyAgentFinishes;
    class DepthProducer;
    class LuminanceProducer;
    class ColourMapProducer;
    class VideoProducer;
    class type;
    class ContinuousMovementCommands;
    class AbsoluteMovementCommands;
    class DiscreteMovementCommands;
    class InventoryCommands;
    class SimpleCraftCommands;
    class ChatCommands;
    class MissionQuitCommands;
    class TurnBasedCommands;
    class ObservationFromRecentCommands;
    class ObservationFromTurnScheduler;
    class ObservationFromSubgoalPositionList;
    class ObservationFromHotBar;
    class ObservationFromFullStats;
    class ObservationFromRay;
    class ObservationFromFullInventory;
    class ObservationFromDiscreteCell;
    class ObservationFromDistance;
    class ObservationFromGrid;
    class ObservationFromNearbyEntities;
    class ObservationFromChat;
    class RewardForDamagingEntity;
    class RewardForReachingPosition;
    class RewardForTouchingBlockType;
    class RewardForSendingCommand;
    class RewardForSendingMatchingChatMessage;
    class RewardForCollectingItem;
    class RewardForDiscardingItem;
    class RewardForMissionEnd;
    class min;
    class max;
    class RewardForStructureCopying;
    class RewardForTimeTaken;
    class RewardForCatchingMob;
    class AgentQuitFromReachingPosition;
    class AgentQuitFromTimeUp;
    class AgentQuitFromTouchingBlockType;
    class AgentQuitFromCollectingItem;
    class AgentQuitFromCatchingMob;
    class AgentQuitFromReachingCommandQuota;
    class Seed;
    class UpdateSpeed;
    class MaterialSeed;
    class GapProbability;
    class StairsProbability;
    class TurnProbability;
    class SizeAndPosition;
    class SizeAndPosition1;
    class Waypoints;
    class AddQuitProducer;
    class AddNavigationObservations;
    class complexity;
    class specification;
    class Parametric;
    class Linear;
    class DepthScaling;
    class viewpoint;
    class ModifierList;
    class requestedPosition;
    class divisions;
    class seed;
    class min1;
    class max1;
  }
}


#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

#include "Types.h"

#include "Mission.h"

namespace malmo
{
  namespace schemas
  {
    class Pos: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::decimal x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::decimal > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::decimal y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::decimal > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::decimal z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::decimal > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // Constructors.
      //
      Pos (const x_type&,
           const y_type&,
           const z_type&);

      Pos (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      Pos (const Pos& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      virtual Pos*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Pos&
      operator= (const Pos& x);

      virtual 
      ~Pos ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
    };

    class PosAndDirection: public ::malmo::schemas::Pos
    {
      public:
      // yaw
      //
      typedef ::malmo::schemas::yaw yaw_type;
      typedef ::xsd::cxx::tree::traits< yaw_type, char > yaw_traits;

      const yaw_type&
      yaw () const;

      yaw_type&
      yaw ();

      void
      yaw (const yaw_type& x);

      void
      yaw (::std::auto_ptr< yaw_type > p);

      static yaw_type
      yaw_default_value ();

      // pitch
      //
      typedef ::malmo::schemas::pitch pitch_type;
      typedef ::xsd::cxx::tree::traits< pitch_type, char > pitch_traits;

      const pitch_type&
      pitch () const;

      pitch_type&
      pitch ();

      void
      pitch (const pitch_type& x);

      void
      pitch (::std::auto_ptr< pitch_type > p);

      static pitch_type
      pitch_default_value ();

      // Constructors.
      //
      PosAndDirection (const x_type&,
                       const y_type&,
                       const z_type&);

      PosAndDirection (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PosAndDirection (const PosAndDirection& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PosAndDirection*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PosAndDirection&
      operator= (const PosAndDirection& x);

      virtual 
      ~PosAndDirection ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< yaw_type > yaw_;
      ::xsd::cxx::tree::one< pitch_type > pitch_;
    };

    class BlockList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::BlockType, char >
    {
      public:
      BlockList ();

      BlockList (size_type n, const ::malmo::schemas::BlockType& x);

      template < typename I >
      BlockList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::BlockType, char > (begin, end, this)
      {
      }

      BlockList (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockList (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockList (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockList (const BlockList& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual BlockList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~BlockList ();
    };

    class ItemList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::ItemType, char >
    {
      public:
      ItemList ();

      ItemList (size_type n, const ::malmo::schemas::ItemType& x);

      template < typename I >
      ItemList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::ItemType, char > (begin, end, this)
      {
      }

      ItemList (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemList (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemList (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemList (const ItemList& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual ItemList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ItemList ();
    };

    class BlockOrItemList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::BlockOrItem, char >
    {
      public:
      BlockOrItemList ();

      BlockOrItemList (size_type n, const ::malmo::schemas::BlockOrItem& x);

      template < typename I >
      BlockOrItemList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::BlockOrItem, char > (begin, end, this)
      {
      }

      BlockOrItemList (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      BlockOrItemList (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      BlockOrItemList (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      BlockOrItemList (const BlockOrItemList& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual BlockOrItemList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~BlockOrItemList ();
    };

    class ColourList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::Colour, char >
    {
      public:
      ColourList ();

      ColourList (size_type n, const ::malmo::schemas::Colour& x);

      template < typename I >
      ColourList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::Colour, char > (begin, end, this)
      {
      }

      ColourList (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ColourList (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ColourList (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      ColourList (const ColourList& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual ColourList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ColourList ();
    };

    class VariantList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::Variation, char >
    {
      public:
      VariantList ();

      VariantList (size_type n, const ::malmo::schemas::Variation& x);

      template < typename I >
      VariantList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::Variation, char > (begin, end, this)
      {
      }

      VariantList (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      VariantList (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      VariantList (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      VariantList (const VariantList& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual VariantList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~VariantList ();
    };

    class MazeBlock: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::BlockList type_type;
      typedef ::xsd::cxx::tree::optional< type_type > type_optional;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_optional&
      type () const;

      type_optional&
      type ();

      void
      type (const type_type& x);

      void
      type (const type_optional& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::VariantList variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::ColourList colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // height
      //
      typedef ::xml_schema::int_ height_type;
      typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

      const height_type&
      height () const;

      height_type&
      height ();

      void
      height (const height_type& x);

      static height_type
      height_default_value ();

      // heightVariance
      //
      typedef ::xml_schema::int_ heightVariance_type;
      typedef ::xsd::cxx::tree::traits< heightVariance_type, char > heightVariance_traits;

      const heightVariance_type&
      heightVariance () const;

      heightVariance_type&
      heightVariance ();

      void
      heightVariance (const heightVariance_type& x);

      static heightVariance_type
      heightVariance_default_value ();

      // Constructors.
      //
      MazeBlock ();

      MazeBlock (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      MazeBlock (const MazeBlock& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual MazeBlock*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MazeBlock&
      operator= (const MazeBlock& x);

      virtual 
      ~MazeBlock ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      type_optional type_;
      variant_optional variant_;
      colour_optional colour_;
      ::xsd::cxx::tree::one< height_type > height_;
      ::xsd::cxx::tree::one< heightVariance_type > heightVariance_;
    };

    class MazeTerminus: public ::malmo::schemas::MazeBlock
    {
      public:
      // fixedToEdge
      //
      typedef ::xml_schema::boolean fixedToEdge_type;
      typedef ::xsd::cxx::tree::traits< fixedToEdge_type, char > fixedToEdge_traits;

      const fixedToEdge_type&
      fixedToEdge () const;

      fixedToEdge_type&
      fixedToEdge ();

      void
      fixedToEdge (const fixedToEdge_type& x);

      static fixedToEdge_type
      fixedToEdge_default_value ();

      // Constructors.
      //
      MazeTerminus ();

      MazeTerminus (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MazeTerminus (const MazeTerminus& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual MazeTerminus*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MazeTerminus&
      operator= (const MazeTerminus& x);

      virtual 
      ~MazeTerminus ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< fixedToEdge_type > fixedToEdge_;
    };

    class SnakeBlock: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::BlockList type_type;
      typedef ::xsd::cxx::tree::optional< type_type > type_optional;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_optional&
      type () const;

      type_optional&
      type ();

      void
      type (const type_type& x);

      void
      type (const type_optional& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::VariantList variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::ColourList colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // lifetime
      //
      typedef ::xml_schema::int_ lifetime_type;
      typedef ::xsd::cxx::tree::traits< lifetime_type, char > lifetime_traits;

      const lifetime_type&
      lifetime () const;

      lifetime_type&
      lifetime ();

      void
      lifetime (const lifetime_type& x);

      static lifetime_type
      lifetime_default_value ();

      // lifetimeVariance
      //
      typedef ::xml_schema::int_ lifetimeVariance_type;
      typedef ::xsd::cxx::tree::traits< lifetimeVariance_type, char > lifetimeVariance_traits;

      const lifetimeVariance_type&
      lifetimeVariance () const;

      lifetimeVariance_type&
      lifetimeVariance ();

      void
      lifetimeVariance (const lifetimeVariance_type& x);

      static lifetimeVariance_type
      lifetimeVariance_default_value ();

      // Constructors.
      //
      SnakeBlock ();

      SnakeBlock (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      SnakeBlock (const SnakeBlock& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual SnakeBlock*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SnakeBlock&
      operator= (const SnakeBlock& x);

      virtual 
      ~SnakeBlock ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      type_optional type_;
      variant_optional variant_;
      colour_optional colour_;
      ::xsd::cxx::tree::one< lifetime_type > lifetime_;
      ::xsd::cxx::tree::one< lifetimeVariance_type > lifetimeVariance_;
    };

    class DrawObjectType: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      DrawObjectType ();

      DrawObjectType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      DrawObjectType (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      DrawObjectType (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      DrawObjectType (const DrawObjectType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual DrawObjectType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~DrawObjectType ();
    };

    class DrawBlockBasedObjectType: public ::malmo::schemas::DrawObjectType
    {
      public:
      // type
      //
      typedef ::malmo::schemas::BlockType type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::Variation variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::Colour colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // face
      //
      typedef ::malmo::schemas::Facing face_type;
      typedef ::xsd::cxx::tree::optional< face_type > face_optional;
      typedef ::xsd::cxx::tree::traits< face_type, char > face_traits;

      const face_optional&
      face () const;

      face_optional&
      face ();

      void
      face (const face_type& x);

      void
      face (const face_optional& x);

      void
      face (::std::auto_ptr< face_type > p);

      // Constructors.
      //
      DrawBlockBasedObjectType (const type_type&);

      DrawBlockBasedObjectType (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DrawBlockBasedObjectType (const DrawBlockBasedObjectType& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DrawBlockBasedObjectType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawBlockBasedObjectType&
      operator= (const DrawBlockBasedObjectType& x);

      virtual 
      ~DrawBlockBasedObjectType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
      face_optional face_;
    };

    class DrawBlock: public ::malmo::schemas::DrawBlockBasedObjectType
    {
      public:
      // x
      //
      typedef ::xml_schema::int_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::int_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::int_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // Constructors.
      //
      DrawBlock (const type_type&,
                 const x_type&,
                 const y_type&,
                 const z_type&);

      DrawBlock (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      DrawBlock (const DrawBlock& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual DrawBlock*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawBlock&
      operator= (const DrawBlock& x);

      virtual 
      ~DrawBlock ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
    };

    class DrawItem: public ::malmo::schemas::DrawObjectType
    {
      public:
      // x
      //
      typedef ::xml_schema::int_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::int_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::int_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // type
      //
      typedef ::malmo::schemas::BlockOrItem type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::Variation variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::Colour colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // face
      //
      typedef ::malmo::schemas::Facing face_type;
      typedef ::xsd::cxx::tree::optional< face_type > face_optional;
      typedef ::xsd::cxx::tree::traits< face_type, char > face_traits;

      const face_optional&
      face () const;

      face_optional&
      face ();

      void
      face (const face_type& x);

      void
      face (const face_optional& x);

      void
      face (::std::auto_ptr< face_type > p);

      // Constructors.
      //
      DrawItem (const x_type&,
                const y_type&,
                const z_type&,
                const type_type&);

      DrawItem (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      DrawItem (const DrawItem& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual DrawItem*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawItem&
      operator= (const DrawItem& x);

      virtual 
      ~DrawItem ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
      face_optional face_;
    };

    class ContainedObjectType: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::BlockOrItem type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::Variation variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::Colour colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // quantity
      //
      typedef ::xml_schema::int_ quantity_type;
      typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

      const quantity_type&
      quantity () const;

      quantity_type&
      quantity ();

      void
      quantity (const quantity_type& x);

      static quantity_type
      quantity_default_value ();

      // Constructors.
      //
      ContainedObjectType (const type_type&);

      ContainedObjectType (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ContainedObjectType (const ContainedObjectType& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ContainedObjectType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ContainedObjectType&
      operator= (const ContainedObjectType& x);

      virtual 
      ~ContainedObjectType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
      ::xsd::cxx::tree::one< quantity_type > quantity_;
    };

    class DrawContainer: public ::malmo::schemas::DrawObjectType
    {
      public:
      // Object
      //
      typedef ::malmo::schemas::ContainedObjectType Object_type;
      typedef ::xsd::cxx::tree::sequence< Object_type > Object_sequence;
      typedef Object_sequence::iterator Object_iterator;
      typedef Object_sequence::const_iterator Object_const_iterator;
      typedef ::xsd::cxx::tree::traits< Object_type, char > Object_traits;

      const Object_sequence&
      Object () const;

      Object_sequence&
      Object ();

      void
      Object (const Object_sequence& s);

      // x
      //
      typedef ::xml_schema::int_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::int_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::int_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // type
      //
      typedef ::malmo::schemas::ContainerType type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::Variation variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::Colour colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // face
      //
      typedef ::malmo::schemas::Facing face_type;
      typedef ::xsd::cxx::tree::optional< face_type > face_optional;
      typedef ::xsd::cxx::tree::traits< face_type, char > face_traits;

      const face_optional&
      face () const;

      face_optional&
      face ();

      void
      face (const face_type& x);

      void
      face (const face_optional& x);

      void
      face (::std::auto_ptr< face_type > p);

      // Constructors.
      //
      DrawContainer (const x_type&,
                     const y_type&,
                     const z_type&,
                     const type_type&);

      DrawContainer (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      DrawContainer (const DrawContainer& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual DrawContainer*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawContainer&
      operator= (const DrawContainer& x);

      virtual 
      ~DrawContainer ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Object_sequence Object_;
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
      face_optional face_;
    };

    class DrawEntity: public ::malmo::schemas::DrawObjectType
    {
      public:
      // x
      //
      typedef ::xml_schema::decimal x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char, ::xsd::cxx::tree::schema_type::decimal > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::decimal y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char, ::xsd::cxx::tree::schema_type::decimal > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::decimal z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char, ::xsd::cxx::tree::schema_type::decimal > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // type
      //
      typedef ::malmo::schemas::SpawnableTypes type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // yaw
      //
      typedef ::xml_schema::decimal yaw_type;
      typedef ::xsd::cxx::tree::traits< yaw_type, char, ::xsd::cxx::tree::schema_type::decimal > yaw_traits;

      const yaw_type&
      yaw () const;

      yaw_type&
      yaw ();

      void
      yaw (const yaw_type& x);

      static yaw_type
      yaw_default_value ();

      // pitch
      //
      typedef ::xml_schema::decimal pitch_type;
      typedef ::xsd::cxx::tree::traits< pitch_type, char, ::xsd::cxx::tree::schema_type::decimal > pitch_traits;

      const pitch_type&
      pitch () const;

      pitch_type&
      pitch ();

      void
      pitch (const pitch_type& x);

      static pitch_type
      pitch_default_value ();

      // xVel
      //
      typedef ::xml_schema::decimal xVel_type;
      typedef ::xsd::cxx::tree::traits< xVel_type, char, ::xsd::cxx::tree::schema_type::decimal > xVel_traits;

      const xVel_type&
      xVel () const;

      xVel_type&
      xVel ();

      void
      xVel (const xVel_type& x);

      static xVel_type
      xVel_default_value ();

      // yVel
      //
      typedef ::xml_schema::decimal yVel_type;
      typedef ::xsd::cxx::tree::traits< yVel_type, char, ::xsd::cxx::tree::schema_type::decimal > yVel_traits;

      const yVel_type&
      yVel () const;

      yVel_type&
      yVel ();

      void
      yVel (const yVel_type& x);

      static yVel_type
      yVel_default_value ();

      // zVel
      //
      typedef ::xml_schema::decimal zVel_type;
      typedef ::xsd::cxx::tree::traits< zVel_type, char, ::xsd::cxx::tree::schema_type::decimal > zVel_traits;

      const zVel_type&
      zVel () const;

      zVel_type&
      zVel ();

      void
      zVel (const zVel_type& x);

      static zVel_type
      zVel_default_value ();

      // Constructors.
      //
      DrawEntity (const x_type&,
                  const y_type&,
                  const z_type&,
                  const type_type&);

      DrawEntity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      DrawEntity (const DrawEntity& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual DrawEntity*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawEntity&
      operator= (const DrawEntity& x);

      virtual 
      ~DrawEntity ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
      ::xsd::cxx::tree::one< type_type > type_;
      ::xsd::cxx::tree::one< yaw_type > yaw_;
      ::xsd::cxx::tree::one< pitch_type > pitch_;
      ::xsd::cxx::tree::one< xVel_type > xVel_;
      ::xsd::cxx::tree::one< yVel_type > yVel_;
      ::xsd::cxx::tree::one< zVel_type > zVel_;
    };

    class DrawCuboid: public ::malmo::schemas::DrawBlockBasedObjectType
    {
      public:
      // x1
      //
      typedef ::xml_schema::int_ x1_type;
      typedef ::xsd::cxx::tree::traits< x1_type, char > x1_traits;

      const x1_type&
      x1 () const;

      x1_type&
      x1 ();

      void
      x1 (const x1_type& x);

      // y1
      //
      typedef ::xml_schema::int_ y1_type;
      typedef ::xsd::cxx::tree::traits< y1_type, char > y1_traits;

      const y1_type&
      y1 () const;

      y1_type&
      y1 ();

      void
      y1 (const y1_type& x);

      // z1
      //
      typedef ::xml_schema::int_ z1_type;
      typedef ::xsd::cxx::tree::traits< z1_type, char > z1_traits;

      const z1_type&
      z1 () const;

      z1_type&
      z1 ();

      void
      z1 (const z1_type& x);

      // x2
      //
      typedef ::xml_schema::int_ x2_type;
      typedef ::xsd::cxx::tree::traits< x2_type, char > x2_traits;

      const x2_type&
      x2 () const;

      x2_type&
      x2 ();

      void
      x2 (const x2_type& x);

      // y2
      //
      typedef ::xml_schema::int_ y2_type;
      typedef ::xsd::cxx::tree::traits< y2_type, char > y2_traits;

      const y2_type&
      y2 () const;

      y2_type&
      y2 ();

      void
      y2 (const y2_type& x);

      // z2
      //
      typedef ::xml_schema::int_ z2_type;
      typedef ::xsd::cxx::tree::traits< z2_type, char > z2_traits;

      const z2_type&
      z2 () const;

      z2_type&
      z2 ();

      void
      z2 (const z2_type& x);

      // Constructors.
      //
      DrawCuboid (const type_type&,
                  const x1_type&,
                  const y1_type&,
                  const z1_type&,
                  const x2_type&,
                  const y2_type&,
                  const z2_type&);

      DrawCuboid (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      DrawCuboid (const DrawCuboid& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual DrawCuboid*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawCuboid&
      operator= (const DrawCuboid& x);

      virtual 
      ~DrawCuboid ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x1_type > x1_;
      ::xsd::cxx::tree::one< y1_type > y1_;
      ::xsd::cxx::tree::one< z1_type > z1_;
      ::xsd::cxx::tree::one< x2_type > x2_;
      ::xsd::cxx::tree::one< y2_type > y2_;
      ::xsd::cxx::tree::one< z2_type > z2_;
    };

    class DrawSphere: public ::malmo::schemas::DrawBlockBasedObjectType
    {
      public:
      // x
      //
      typedef ::xml_schema::int_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::int_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::int_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // radius
      //
      typedef ::xml_schema::int_ radius_type;
      typedef ::xsd::cxx::tree::traits< radius_type, char > radius_traits;

      const radius_type&
      radius () const;

      radius_type&
      radius ();

      void
      radius (const radius_type& x);

      // Constructors.
      //
      DrawSphere (const type_type&,
                  const x_type&,
                  const y_type&,
                  const z_type&,
                  const radius_type&);

      DrawSphere (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      DrawSphere (const DrawSphere& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual DrawSphere*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawSphere&
      operator= (const DrawSphere& x);

      virtual 
      ~DrawSphere ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
      ::xsd::cxx::tree::one< radius_type > radius_;
    };

    class DrawLine: public ::malmo::schemas::DrawBlockBasedObjectType
    {
      public:
      // x1
      //
      typedef ::xml_schema::int_ x1_type;
      typedef ::xsd::cxx::tree::traits< x1_type, char > x1_traits;

      const x1_type&
      x1 () const;

      x1_type&
      x1 ();

      void
      x1 (const x1_type& x);

      // y1
      //
      typedef ::xml_schema::int_ y1_type;
      typedef ::xsd::cxx::tree::traits< y1_type, char > y1_traits;

      const y1_type&
      y1 () const;

      y1_type&
      y1 ();

      void
      y1 (const y1_type& x);

      // z1
      //
      typedef ::xml_schema::int_ z1_type;
      typedef ::xsd::cxx::tree::traits< z1_type, char > z1_traits;

      const z1_type&
      z1 () const;

      z1_type&
      z1 ();

      void
      z1 (const z1_type& x);

      // x2
      //
      typedef ::xml_schema::int_ x2_type;
      typedef ::xsd::cxx::tree::traits< x2_type, char > x2_traits;

      const x2_type&
      x2 () const;

      x2_type&
      x2 ();

      void
      x2 (const x2_type& x);

      // y2
      //
      typedef ::xml_schema::int_ y2_type;
      typedef ::xsd::cxx::tree::traits< y2_type, char > y2_traits;

      const y2_type&
      y2 () const;

      y2_type&
      y2 ();

      void
      y2 (const y2_type& x);

      // z2
      //
      typedef ::xml_schema::int_ z2_type;
      typedef ::xsd::cxx::tree::traits< z2_type, char > z2_traits;

      const z2_type&
      z2 () const;

      z2_type&
      z2 ();

      void
      z2 (const z2_type& x);

      // steptype
      //
      typedef ::malmo::schemas::BlockType steptype_type;
      typedef ::xsd::cxx::tree::optional< steptype_type > steptype_optional;
      typedef ::xsd::cxx::tree::traits< steptype_type, char > steptype_traits;

      const steptype_optional&
      steptype () const;

      steptype_optional&
      steptype ();

      void
      steptype (const steptype_type& x);

      void
      steptype (const steptype_optional& x);

      void
      steptype (::std::auto_ptr< steptype_type > p);

      // Constructors.
      //
      DrawLine (const type_type&,
                const x1_type&,
                const y1_type&,
                const z1_type&,
                const x2_type&,
                const y2_type&,
                const z2_type&);

      DrawLine (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      DrawLine (const DrawLine& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual DrawLine*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawLine&
      operator= (const DrawLine& x);

      virtual 
      ~DrawLine ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x1_type > x1_;
      ::xsd::cxx::tree::one< y1_type > y1_;
      ::xsd::cxx::tree::one< z1_type > z1_;
      ::xsd::cxx::tree::one< x2_type > x2_;
      ::xsd::cxx::tree::one< y2_type > y2_;
      ::xsd::cxx::tree::one< z2_type > z2_;
      steptype_optional steptype_;
    };

    class PaletteEnum: public ::xml_schema::string
    {
      public:
      enum value
      {
        default_,
        random,
        dungeon,
        pyramid,
        igloo
      };

      PaletteEnum (value v);

      PaletteEnum (const char* v);

      PaletteEnum (const ::std::string& v);

      PaletteEnum (const ::xml_schema::string& v);

      PaletteEnum (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      PaletteEnum (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      PaletteEnum (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      PaletteEnum (const PaletteEnum& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual PaletteEnum*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PaletteEnum&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_PaletteEnum_convert ();
      }

      protected:
      value
      _xsd_PaletteEnum_convert () const;

      public:
      static const char* const _xsd_PaletteEnum_literals_[5];
      static const value _xsd_PaletteEnum_indexes_[5];
    };

    class HorizontalObstacles: public ::xml_schema::type
    {
      public:
      // gap
      //
      typedef ::malmo::schemas::NonNegative gap_type;
      typedef ::xsd::cxx::tree::traits< gap_type, char > gap_traits;

      const gap_type&
      gap () const;

      gap_type&
      gap ();

      void
      gap (const gap_type& x);

      void
      gap (::std::auto_ptr< gap_type > p);

      // bridge
      //
      typedef ::malmo::schemas::NonNegative bridge_type;
      typedef ::xsd::cxx::tree::traits< bridge_type, char > bridge_traits;

      const bridge_type&
      bridge () const;

      bridge_type&
      bridge ();

      void
      bridge (const bridge_type& x);

      void
      bridge (::std::auto_ptr< bridge_type > p);

      // door
      //
      typedef ::malmo::schemas::NonNegative door_type;
      typedef ::xsd::cxx::tree::traits< door_type, char > door_traits;

      const door_type&
      door () const;

      door_type&
      door ();

      void
      door (const door_type& x);

      void
      door (::std::auto_ptr< door_type > p);

      // puzzle
      //
      typedef ::malmo::schemas::NonNegative puzzle_type;
      typedef ::xsd::cxx::tree::traits< puzzle_type, char > puzzle_traits;

      const puzzle_type&
      puzzle () const;

      puzzle_type&
      puzzle ();

      void
      puzzle (const puzzle_type& x);

      void
      puzzle (::std::auto_ptr< puzzle_type > p);

      // jump
      //
      typedef ::malmo::schemas::NonNegative jump_type;
      typedef ::xsd::cxx::tree::traits< jump_type, char > jump_traits;

      const jump_type&
      jump () const;

      jump_type&
      jump ();

      void
      jump (const jump_type& x);

      void
      jump (::std::auto_ptr< jump_type > p);

      // Constructors.
      //
      HorizontalObstacles (const gap_type&,
                           const bridge_type&,
                           const door_type&,
                           const puzzle_type&,
                           const jump_type&);

      HorizontalObstacles (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      HorizontalObstacles (const HorizontalObstacles& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual HorizontalObstacles*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      HorizontalObstacles&
      operator= (const HorizontalObstacles& x);

      virtual 
      ~HorizontalObstacles ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< gap_type > gap_;
      ::xsd::cxx::tree::one< bridge_type > bridge_;
      ::xsd::cxx::tree::one< door_type > door_;
      ::xsd::cxx::tree::one< puzzle_type > puzzle_;
      ::xsd::cxx::tree::one< jump_type > jump_;
    };

    class VerticalObstacles: public ::xml_schema::type
    {
      public:
      // stairs
      //
      typedef ::malmo::schemas::NonNegative stairs_type;
      typedef ::xsd::cxx::tree::traits< stairs_type, char > stairs_traits;

      const stairs_type&
      stairs () const;

      stairs_type&
      stairs ();

      void
      stairs (const stairs_type& x);

      void
      stairs (::std::auto_ptr< stairs_type > p);

      // ladder
      //
      typedef ::malmo::schemas::NonNegative ladder_type;
      typedef ::xsd::cxx::tree::traits< ladder_type, char > ladder_traits;

      const ladder_type&
      ladder () const;

      ladder_type&
      ladder ();

      void
      ladder (const ladder_type& x);

      void
      ladder (::std::auto_ptr< ladder_type > p);

      // jump
      //
      typedef ::malmo::schemas::NonNegative jump_type;
      typedef ::xsd::cxx::tree::traits< jump_type, char > jump_traits;

      const jump_type&
      jump () const;

      jump_type&
      jump ();

      void
      jump (const jump_type& x);

      void
      jump (::std::auto_ptr< jump_type > p);

      // Constructors.
      //
      VerticalObstacles (const stairs_type&,
                         const ladder_type&,
                         const jump_type&);

      VerticalObstacles (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      VerticalObstacles (const VerticalObstacles& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual VerticalObstacles*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VerticalObstacles&
      operator= (const VerticalObstacles& x);

      virtual 
      ~VerticalObstacles ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< stairs_type > stairs_;
      ::xsd::cxx::tree::one< ladder_type > ladder_;
      ::xsd::cxx::tree::one< jump_type > jump_;
    };

    class BuildingSize: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      BuildingSize (const ::xml_schema::int_&);

      BuildingSize (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      BuildingSize (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      BuildingSize (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      BuildingSize (const BuildingSize& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual BuildingSize*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~BuildingSize ();
    };

    class ZeroToOne: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::double_ >
    {
      public:
      // Constructors.
      //
      ZeroToOne (const ::xml_schema::double_&);

      ZeroToOne (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      ZeroToOne (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      ZeroToOne (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      ZeroToOne (const ZeroToOne& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual ZeroToOne*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ZeroToOne ();
    };

    class NonNegative: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      NonNegative (const ::xml_schema::int_&);

      NonNegative (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NonNegative (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NonNegative (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      NonNegative (const NonNegative& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual NonNegative*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~NonNegative ();
    };

    class HexColour: public ::xml_schema::hex_binary
    {
      public:
      // Constructors.
      //
      HexColour ();

      HexColour (const ::xml_schema::hex_binary&);

      HexColour (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      HexColour (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      HexColour (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      HexColour (const HexColour& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual HexColour*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~HexColour ();
    };

    class MobWithColour: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::MobList type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // colour
      //
      typedef ::malmo::schemas::HexColour colour_type;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_type&
      colour () const;

      colour_type&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // Constructors.
      //
      MobWithColour (const type_type&,
                     const colour_type&);

      MobWithColour (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      MobWithColour (const MobWithColour& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual MobWithColour*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MobWithColour&
      operator= (const MobWithColour& x);

      virtual 
      ~MobWithColour ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      ::xsd::cxx::tree::one< colour_type > colour_;
    };

    class ContinuousMovementCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        move,
        strafe,
        pitch,
        turn,
        jump,
        crouch,
        attack,
        use
      };

      ContinuousMovementCommand (value v);

      ContinuousMovementCommand (const char* v);

      ContinuousMovementCommand (const ::std::string& v);

      ContinuousMovementCommand (const ::xml_schema::string& v);

      ContinuousMovementCommand (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ContinuousMovementCommand (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ContinuousMovementCommand (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      ContinuousMovementCommand (const ContinuousMovementCommand& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual ContinuousMovementCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ContinuousMovementCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ContinuousMovementCommand_convert ();
      }

      protected:
      value
      _xsd_ContinuousMovementCommand_convert () const;

      public:
      static const char* const _xsd_ContinuousMovementCommand_literals_[8];
      static const value _xsd_ContinuousMovementCommand_indexes_[8];
    };

    class AbsoluteMovementCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        tpx,
        tpy,
        tpz,
        tp,
        setYaw,
        setPitch
      };

      AbsoluteMovementCommand (value v);

      AbsoluteMovementCommand (const char* v);

      AbsoluteMovementCommand (const ::std::string& v);

      AbsoluteMovementCommand (const ::xml_schema::string& v);

      AbsoluteMovementCommand (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AbsoluteMovementCommand (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AbsoluteMovementCommand (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      AbsoluteMovementCommand (const AbsoluteMovementCommand& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual AbsoluteMovementCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AbsoluteMovementCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_AbsoluteMovementCommand_convert ();
      }

      protected:
      value
      _xsd_AbsoluteMovementCommand_convert () const;

      public:
      static const char* const _xsd_AbsoluteMovementCommand_literals_[6];
      static const value _xsd_AbsoluteMovementCommand_indexes_[6];
    };

    class DiscreteMovementCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        move,
        jumpmove,
        strafe,
        jumpstrafe,
        turn,
        movenorth,
        moveeast,
        movesouth,
        movewest,
        jumpnorth,
        jumpeast,
        jumpsouth,
        jumpwest,
        jump,
        look,
        attack,
        use,
        jumpuse
      };

      DiscreteMovementCommand (value v);

      DiscreteMovementCommand (const char* v);

      DiscreteMovementCommand (const ::std::string& v);

      DiscreteMovementCommand (const ::xml_schema::string& v);

      DiscreteMovementCommand (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DiscreteMovementCommand (const ::xercesc::DOMAttr& a,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DiscreteMovementCommand (const ::std::string& s,
                               const ::xercesc::DOMElement* e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      DiscreteMovementCommand (const DiscreteMovementCommand& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual DiscreteMovementCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DiscreteMovementCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_DiscreteMovementCommand_convert ();
      }

      protected:
      value
      _xsd_DiscreteMovementCommand_convert () const;

      public:
      static const char* const _xsd_DiscreteMovementCommand_literals_[18];
      static const value _xsd_DiscreteMovementCommand_indexes_[18];
    };

    class InventoryCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        swapInventoryItems,
        combineInventoryItems,
        discardCurrentItem,
        hotbar_1,
        hotbar_2,
        hotbar_3,
        hotbar_4,
        hotbar_5,
        hotbar_6,
        hotbar_7,
        hotbar_8,
        hotbar_9
      };

      InventoryCommand (value v);

      InventoryCommand (const char* v);

      InventoryCommand (const ::std::string& v);

      InventoryCommand (const ::xml_schema::string& v);

      InventoryCommand (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      InventoryCommand (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      InventoryCommand (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      InventoryCommand (const InventoryCommand& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual InventoryCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InventoryCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_InventoryCommand_convert ();
      }

      protected:
      value
      _xsd_InventoryCommand_convert () const;

      public:
      static const char* const _xsd_InventoryCommand_literals_[12];
      static const value _xsd_InventoryCommand_indexes_[12];
    };

    class SimpleCraftCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        craft
      };

      SimpleCraftCommand (value v);

      SimpleCraftCommand (const char* v);

      SimpleCraftCommand (const ::std::string& v);

      SimpleCraftCommand (const ::xml_schema::string& v);

      SimpleCraftCommand (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SimpleCraftCommand (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SimpleCraftCommand (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      SimpleCraftCommand (const SimpleCraftCommand& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual SimpleCraftCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimpleCraftCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_SimpleCraftCommand_convert ();
      }

      protected:
      value
      _xsd_SimpleCraftCommand_convert () const;

      public:
      static const char* const _xsd_SimpleCraftCommand_literals_[1];
      static const value _xsd_SimpleCraftCommand_indexes_[1];
    };

    class ChatCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        chat
      };

      ChatCommand (value v);

      ChatCommand (const char* v);

      ChatCommand (const ::std::string& v);

      ChatCommand (const ::xml_schema::string& v);

      ChatCommand (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ChatCommand (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ChatCommand (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      ChatCommand (const ChatCommand& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual ChatCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ChatCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_ChatCommand_convert ();
      }

      protected:
      value
      _xsd_ChatCommand_convert () const;

      public:
      static const char* const _xsd_ChatCommand_literals_[1];
      static const value _xsd_ChatCommand_indexes_[1];
    };

    class MissionQuitCommand: public ::xml_schema::string
    {
      public:
      enum value
      {
        quit
      };

      MissionQuitCommand (value v);

      MissionQuitCommand (const char* v);

      MissionQuitCommand (const ::std::string& v);

      MissionQuitCommand (const ::xml_schema::string& v);

      MissionQuitCommand (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      MissionQuitCommand (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      MissionQuitCommand (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      MissionQuitCommand (const MissionQuitCommand& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual MissionQuitCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MissionQuitCommand&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_MissionQuitCommand_convert ();
      }

      protected:
      value
      _xsd_MissionQuitCommand_convert () const;

      public:
      static const char* const _xsd_MissionQuitCommand_literals_[1];
      static const value _xsd_MissionQuitCommand_indexes_[1];
    };

    class Command: public ::xml_schema::string
    {
      public:
      enum value
      {
        move,
        strafe,
        pitch,
        turn,
        jump,
        crouch,
        attack,
        use,
        tpx,
        tpy,
        tpz,
        tp,
        setYaw,
        setPitch,
        jumpmove,
        jumpstrafe,
        movenorth,
        moveeast,
        movesouth,
        movewest,
        jumpnorth,
        jumpeast,
        jumpsouth,
        jumpwest,
        look,
        jumpuse,
        swapInventoryItems,
        combineInventoryItems,
        discardCurrentItem,
        hotbar_1,
        hotbar_2,
        hotbar_3,
        hotbar_4,
        hotbar_5,
        hotbar_6,
        hotbar_7,
        hotbar_8,
        hotbar_9,
        chat,
        craft,
        quit
      };

      Command (value v);

      Command (const char* v);

      Command (const ::std::string& v);

      Command (const ::xml_schema::string& v);

      Command (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Command (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Command (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      Command (const Command& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual Command*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Command&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Command_convert ();
      }

      protected:
      value
      _xsd_Command_convert () const;

      public:
      static const char* const _xsd_Command_literals_[41];
      static const value _xsd_Command_indexes_[41];
    };

    class CommandList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::Command, char >
    {
      public:
      CommandList ();

      CommandList (size_type n, const ::malmo::schemas::Command& x);

      template < typename I >
      CommandList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::Command, char > (begin, end, this)
      {
      }

      CommandList (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CommandList (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CommandList (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      CommandList (const CommandList& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual CommandList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~CommandList ();
    };

    class CommandListModifier: public ::xml_schema::type
    {
      public:
      // command
      //
      typedef ::xml_schema::string command_type;
      typedef ::xsd::cxx::tree::sequence< command_type > command_sequence;
      typedef command_sequence::iterator command_iterator;
      typedef command_sequence::const_iterator command_const_iterator;
      typedef ::xsd::cxx::tree::traits< command_type, char > command_traits;

      const command_sequence&
      command () const;

      command_sequence&
      command ();

      void
      command (const command_sequence& s);

      // type
      //
      typedef ::malmo::schemas::type type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      static const type_type&
      type_default_value ();

      // Constructors.
      //
      CommandListModifier ();

      CommandListModifier (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      CommandListModifier (const CommandListModifier& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual CommandListModifier*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CommandListModifier&
      operator= (const CommandListModifier& x);

      virtual 
      ~CommandListModifier ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      command_sequence command_;
      ::xsd::cxx::tree::one< type_type > type_;
      static const type_type type_default_value_;
    };

    class NamedPoint: public ::malmo::schemas::Pos
    {
      public:
      // name
      //
      typedef ::xml_schema::name name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::auto_ptr< name_type > p);

      // Constructors.
      //
      NamedPoint (const x_type&,
                  const y_type&,
                  const z_type&,
                  const name_type&);

      NamedPoint (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      NamedPoint (const NamedPoint& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual NamedPoint*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      NamedPoint&
      operator= (const NamedPoint& x);

      virtual 
      ~NamedPoint ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
    };

    class GridDefinition: public ::xml_schema::type
    {
      public:
      // min
      //
      typedef ::malmo::schemas::Pos min_type;
      typedef ::xsd::cxx::tree::traits< min_type, char > min_traits;

      const min_type&
      min () const;

      min_type&
      min ();

      void
      min (const min_type& x);

      void
      min (::std::auto_ptr< min_type > p);

      // max
      //
      typedef ::malmo::schemas::Pos max_type;
      typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

      const max_type&
      max () const;

      max_type&
      max ();

      void
      max (const max_type& x);

      void
      max (::std::auto_ptr< max_type > p);

      // name
      //
      typedef ::xml_schema::name name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::auto_ptr< name_type > p);

      // absoluteCoords
      //
      typedef ::xml_schema::boolean absoluteCoords_type;
      typedef ::xsd::cxx::tree::traits< absoluteCoords_type, char > absoluteCoords_traits;

      const absoluteCoords_type&
      absoluteCoords () const;

      absoluteCoords_type&
      absoluteCoords ();

      void
      absoluteCoords (const absoluteCoords_type& x);

      static absoluteCoords_type
      absoluteCoords_default_value ();

      // Constructors.
      //
      GridDefinition (const min_type&,
                      const max_type&,
                      const name_type&);

      GridDefinition (::std::auto_ptr< min_type >,
                      ::std::auto_ptr< max_type >,
                      const name_type&);

      GridDefinition (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      GridDefinition (const GridDefinition& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual GridDefinition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GridDefinition&
      operator= (const GridDefinition& x);

      virtual 
      ~GridDefinition ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< min_type > min_;
      ::xsd::cxx::tree::one< max_type > max_;
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< absoluteCoords_type > absoluteCoords_;
    };

    class RangeDefinition: public ::xml_schema::type
    {
      public:
      // name
      //
      typedef ::xml_schema::name name_type;
      typedef ::xsd::cxx::tree::traits< name_type, char > name_traits;

      const name_type&
      name () const;

      name_type&
      name ();

      void
      name (const name_type& x);

      void
      name (::std::auto_ptr< name_type > p);

      // xrange
      //
      typedef ::xml_schema::decimal xrange_type;
      typedef ::xsd::cxx::tree::traits< xrange_type, char, ::xsd::cxx::tree::schema_type::decimal > xrange_traits;

      const xrange_type&
      xrange () const;

      xrange_type&
      xrange ();

      void
      xrange (const xrange_type& x);

      // yrange
      //
      typedef ::xml_schema::decimal yrange_type;
      typedef ::xsd::cxx::tree::traits< yrange_type, char, ::xsd::cxx::tree::schema_type::decimal > yrange_traits;

      const yrange_type&
      yrange () const;

      yrange_type&
      yrange ();

      void
      yrange (const yrange_type& x);

      // zrange
      //
      typedef ::xml_schema::decimal zrange_type;
      typedef ::xsd::cxx::tree::traits< zrange_type, char, ::xsd::cxx::tree::schema_type::decimal > zrange_traits;

      const zrange_type&
      zrange () const;

      zrange_type&
      zrange ();

      void
      zrange (const zrange_type& x);

      // update_frequency
      //
      typedef ::xml_schema::int_ update_frequency_type;
      typedef ::xsd::cxx::tree::traits< update_frequency_type, char > update_frequency_traits;

      const update_frequency_type&
      update_frequency () const;

      update_frequency_type&
      update_frequency ();

      void
      update_frequency (const update_frequency_type& x);

      static update_frequency_type
      update_frequency_default_value ();

      // Constructors.
      //
      RangeDefinition (const name_type&,
                       const xrange_type&,
                       const yrange_type&,
                       const zrange_type&);

      RangeDefinition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      RangeDefinition (const RangeDefinition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual RangeDefinition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RangeDefinition&
      operator= (const RangeDefinition& x);

      virtual 
      ~RangeDefinition ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< name_type > name_;
      ::xsd::cxx::tree::one< xrange_type > xrange_;
      ::xsd::cxx::tree::one< yrange_type > yrange_;
      ::xsd::cxx::tree::one< zrange_type > zrange_;
      ::xsd::cxx::tree::one< update_frequency_type > update_frequency_;
    };

    class Dimension: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      Dimension (const ::xml_schema::int_&);

      Dimension (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Dimension (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Dimension (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Dimension (const Dimension& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual Dimension*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Dimension ();
    };

    class PointWithReward: public ::malmo::schemas::Pos
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // tolerance
      //
      typedef ::xml_schema::decimal tolerance_type;
      typedef ::xsd::cxx::tree::traits< tolerance_type, char, ::xsd::cxx::tree::schema_type::decimal > tolerance_traits;

      const tolerance_type&
      tolerance () const;

      tolerance_type&
      tolerance ();

      void
      tolerance (const tolerance_type& x);

      // oneshot
      //
      typedef ::xml_schema::boolean oneshot_type;
      typedef ::xsd::cxx::tree::traits< oneshot_type, char > oneshot_traits;

      const oneshot_type&
      oneshot () const;

      oneshot_type&
      oneshot ();

      void
      oneshot (const oneshot_type& x);

      static oneshot_type
      oneshot_default_value ();

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // Constructors.
      //
      PointWithReward (const x_type&,
                       const y_type&,
                       const z_type&,
                       const reward_type&,
                       const tolerance_type&);

      PointWithReward (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      PointWithReward (const PointWithReward& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual PointWithReward*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointWithReward&
      operator= (const PointWithReward& x);

      virtual 
      ~PointWithReward ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< tolerance_type > tolerance_;
      ::xsd::cxx::tree::one< oneshot_type > oneshot_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
    };

    class MobWithReward: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::MobList type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // Constructors.
      //
      MobWithReward (const type_type&,
                     const reward_type&);

      MobWithReward (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      MobWithReward (const MobWithReward& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual MobWithReward*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MobWithReward&
      operator= (const MobWithReward& x);

      virtual 
      ~MobWithReward ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
    };

    class BlockSpec: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::BlockList type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::VariantList variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::ColourList colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // Constructors.
      //
      BlockSpec (const type_type&);

      BlockSpec (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      BlockSpec (const BlockSpec& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual BlockSpec*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockSpec&
      operator= (const BlockSpec& x);

      virtual 
      ~BlockSpec ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
    };

    class BlockOrItemSpec: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::BlockOrItemList type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // variant
      //
      typedef ::malmo::schemas::VariantList variant_type;
      typedef ::xsd::cxx::tree::optional< variant_type > variant_optional;
      typedef ::xsd::cxx::tree::traits< variant_type, char > variant_traits;

      const variant_optional&
      variant () const;

      variant_optional&
      variant ();

      void
      variant (const variant_type& x);

      void
      variant (const variant_optional& x);

      void
      variant (::std::auto_ptr< variant_type > p);

      // colour
      //
      typedef ::malmo::schemas::ColourList colour_type;
      typedef ::xsd::cxx::tree::optional< colour_type > colour_optional;
      typedef ::xsd::cxx::tree::traits< colour_type, char > colour_traits;

      const colour_optional&
      colour () const;

      colour_optional&
      colour ();

      void
      colour (const colour_type& x);

      void
      colour (const colour_optional& x);

      void
      colour (::std::auto_ptr< colour_type > p);

      // Constructors.
      //
      BlockOrItemSpec (const type_type&);

      BlockOrItemSpec (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      BlockOrItemSpec (const BlockOrItemSpec& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual BlockOrItemSpec*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockOrItemSpec&
      operator= (const BlockOrItemSpec& x);

      virtual 
      ~BlockOrItemSpec ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      variant_optional variant_;
      colour_optional colour_;
    };

    class BlockSpecWithRewardAndBehaviour: public ::malmo::schemas::BlockSpec
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // behaviour
      //
      typedef ::malmo::schemas::Behaviour behaviour_type;
      typedef ::xsd::cxx::tree::traits< behaviour_type, char > behaviour_traits;

      const behaviour_type&
      behaviour () const;

      behaviour_type&
      behaviour ();

      void
      behaviour (const behaviour_type& x);

      void
      behaviour (::std::auto_ptr< behaviour_type > p);

      static const behaviour_type&
      behaviour_default_value ();

      // cooldownInMs
      //
      typedef ::xml_schema::decimal cooldownInMs_type;
      typedef ::xsd::cxx::tree::traits< cooldownInMs_type, char, ::xsd::cxx::tree::schema_type::decimal > cooldownInMs_traits;

      const cooldownInMs_type&
      cooldownInMs () const;

      cooldownInMs_type&
      cooldownInMs ();

      void
      cooldownInMs (const cooldownInMs_type& x);

      static cooldownInMs_type
      cooldownInMs_default_value ();

      // Constructors.
      //
      BlockSpecWithRewardAndBehaviour (const type_type&,
                                       const reward_type&);

      BlockSpecWithRewardAndBehaviour (const ::xercesc::DOMElement& e,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      BlockSpecWithRewardAndBehaviour (const BlockSpecWithRewardAndBehaviour& x,
                                       ::xml_schema::flags f = 0,
                                       ::xml_schema::container* c = 0);

      virtual BlockSpecWithRewardAndBehaviour*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockSpecWithRewardAndBehaviour&
      operator= (const BlockSpecWithRewardAndBehaviour& x);

      virtual 
      ~BlockSpecWithRewardAndBehaviour ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
      ::xsd::cxx::tree::one< behaviour_type > behaviour_;
      static const behaviour_type behaviour_default_value_;
      ::xsd::cxx::tree::one< cooldownInMs_type > cooldownInMs_;
    };

    class BlockOrItemSpecWithReward: public ::malmo::schemas::BlockOrItemSpec
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // Constructors.
      //
      BlockOrItemSpecWithReward (const type_type&,
                                 const reward_type&);

      BlockOrItemSpecWithReward (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      BlockOrItemSpecWithReward (const BlockOrItemSpecWithReward& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual BlockOrItemSpecWithReward*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockOrItemSpecWithReward&
      operator= (const BlockOrItemSpecWithReward& x);

      virtual 
      ~BlockOrItemSpecWithReward ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
    };

    class Behaviour: public ::xml_schema::string
    {
      public:
      enum value
      {
        onceOnly,
        oncePerBlock,
        oncePerTimeSpan,
        constant
      };

      Behaviour (value v);

      Behaviour (const char* v);

      Behaviour (const ::std::string& v);

      Behaviour (const ::xml_schema::string& v);

      Behaviour (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Behaviour (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Behaviour (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Behaviour (const Behaviour& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual Behaviour*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Behaviour&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_Behaviour_convert ();
      }

      protected:
      value
      _xsd_Behaviour_convert () const;

      public:
      static const char* const _xsd_Behaviour_literals_[4];
      static const value _xsd_Behaviour_indexes_[4];
    };

    class ChatMatchSpec: public ::xml_schema::type
    {
      public:
      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // regex
      //
      typedef ::xml_schema::string regex_type;
      typedef ::xsd::cxx::tree::traits< regex_type, char > regex_traits;

      const regex_type&
      regex () const;

      regex_type&
      regex ();

      void
      regex (const regex_type& x);

      void
      regex (::std::auto_ptr< regex_type > p);

      // Constructors.
      //
      ChatMatchSpec (const description_type&,
                     const reward_type&,
                     const regex_type&);

      ChatMatchSpec (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      ChatMatchSpec (const ChatMatchSpec& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual ChatMatchSpec*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ChatMatchSpec&
      operator= (const ChatMatchSpec& x);

      virtual 
      ~ChatMatchSpec ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< description_type > description_;
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
      ::xsd::cxx::tree::one< regex_type > regex_;
    };

    class ItemSpec: public ::xml_schema::type
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // type
      //
      typedef ::malmo::schemas::BlockOrItemList type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // Constructors.
      //
      ItemSpec (const reward_type&,
                const type_type&);

      ItemSpec (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      ItemSpec (const ItemSpec& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

      virtual ItemSpec*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ItemSpec&
      operator= (const ItemSpec& x);

      virtual 
      ~ItemSpec ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
      ::xsd::cxx::tree::one< type_type > type_;
    };

    class MissionEndRewardCase: public ::xml_schema::type
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      // Constructors.
      //
      MissionEndRewardCase (const reward_type&,
                            const description_type&);

      MissionEndRewardCase (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      MissionEndRewardCase (const MissionEndRewardCase& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual MissionEndRewardCase*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MissionEndRewardCase&
      operator= (const MissionEndRewardCase& x);

      virtual 
      ~MissionEndRewardCase ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
      ::xsd::cxx::tree::one< description_type > description_;
    };

    class RewardDensityForBuildAndBreak: public ::xml_schema::string
    {
      public:
      enum value
      {
        PER_BLOCK,
        MISSION_END
      };

      RewardDensityForBuildAndBreak (value v);

      RewardDensityForBuildAndBreak (const char* v);

      RewardDensityForBuildAndBreak (const ::std::string& v);

      RewardDensityForBuildAndBreak (const ::xml_schema::string& v);

      RewardDensityForBuildAndBreak (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      RewardDensityForBuildAndBreak (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      RewardDensityForBuildAndBreak (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      RewardDensityForBuildAndBreak (const RewardDensityForBuildAndBreak& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual RewardDensityForBuildAndBreak*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardDensityForBuildAndBreak&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RewardDensityForBuildAndBreak_convert ();
      }

      protected:
      value
      _xsd_RewardDensityForBuildAndBreak_convert () const;

      public:
      static const char* const _xsd_RewardDensityForBuildAndBreak_literals_[2];
      static const value _xsd_RewardDensityForBuildAndBreak_indexes_[2];
    };

    class UnnamedGridDefinition: public ::xml_schema::type
    {
      public:
      // min
      //
      typedef ::malmo::schemas::min min_type;
      typedef ::xsd::cxx::tree::traits< min_type, char > min_traits;

      const min_type&
      min () const;

      min_type&
      min ();

      void
      min (const min_type& x);

      void
      min (::std::auto_ptr< min_type > p);

      // max
      //
      typedef ::malmo::schemas::max max_type;
      typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

      const max_type&
      max () const;

      max_type&
      max ();

      void
      max (const max_type& x);

      void
      max (::std::auto_ptr< max_type > p);

      // Constructors.
      //
      UnnamedGridDefinition (const min_type&,
                             const max_type&);

      UnnamedGridDefinition (::std::auto_ptr< min_type >,
                             ::std::auto_ptr< max_type >);

      UnnamedGridDefinition (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      UnnamedGridDefinition (const UnnamedGridDefinition& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual UnnamedGridDefinition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      UnnamedGridDefinition&
      operator= (const UnnamedGridDefinition& x);

      virtual 
      ~UnnamedGridDefinition ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< min_type > min_;
      ::xsd::cxx::tree::one< max_type > max_;
    };

    class RewardDensityForTimeTaken: public ::xml_schema::string
    {
      public:
      enum value
      {
        PER_TICK,
        PER_TICK_ACCUMULATED,
        MISSION_END
      };

      RewardDensityForTimeTaken (value v);

      RewardDensityForTimeTaken (const char* v);

      RewardDensityForTimeTaken (const ::std::string& v);

      RewardDensityForTimeTaken (const ::xml_schema::string& v);

      RewardDensityForTimeTaken (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      RewardDensityForTimeTaken (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      RewardDensityForTimeTaken (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      RewardDensityForTimeTaken (const RewardDensityForTimeTaken& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual RewardDensityForTimeTaken*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardDensityForTimeTaken&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_RewardDensityForTimeTaken_convert ();
      }

      protected:
      value
      _xsd_RewardDensityForTimeTaken_convert () const;

      public:
      static const char* const _xsd_RewardDensityForTimeTaken_literals_[3];
      static const value _xsd_RewardDensityForTimeTaken_indexes_[3];
    };

    class MobWithDescription: public ::xml_schema::type
    {
      public:
      // type
      //
      typedef ::malmo::schemas::MobList type_type;
      typedef ::xsd::cxx::tree::traits< type_type, char > type_traits;

      const type_type&
      type () const;

      type_type&
      type ();

      void
      type (const type_type& x);

      void
      type (::std::auto_ptr< type_type > p);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // global
      //
      typedef ::xml_schema::boolean global_type;
      typedef ::xsd::cxx::tree::traits< global_type, char > global_traits;

      const global_type&
      global () const;

      global_type&
      global ();

      void
      global (const global_type& x);

      static global_type
      global_default_value ();

      // Constructors.
      //
      MobWithDescription (const type_type&);

      MobWithDescription (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      MobWithDescription (const MobWithDescription& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual MobWithDescription*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MobWithDescription&
      operator= (const MobWithDescription& x);

      virtual 
      ~MobWithDescription ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< type_type > type_;
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
      ::xsd::cxx::tree::one< global_type > global_;
    };

    class MobWithDescriptionAndReward: public ::malmo::schemas::MobWithDescription
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // oneshot
      //
      typedef ::xml_schema::boolean oneshot_type;
      typedef ::xsd::cxx::tree::traits< oneshot_type, char > oneshot_traits;

      const oneshot_type&
      oneshot () const;

      oneshot_type&
      oneshot ();

      void
      oneshot (const oneshot_type& x);

      static oneshot_type
      oneshot_default_value ();

      // Constructors.
      //
      MobWithDescriptionAndReward (const type_type&,
                                   const reward_type&);

      MobWithDescriptionAndReward (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      MobWithDescriptionAndReward (const MobWithDescriptionAndReward& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual MobWithDescriptionAndReward*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MobWithDescriptionAndReward&
      operator= (const MobWithDescriptionAndReward& x);

      virtual 
      ~MobWithDescriptionAndReward ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
      ::xsd::cxx::tree::one< oneshot_type > oneshot_;
    };

    class PointWithToleranceAndDescription: public ::malmo::schemas::Pos
    {
      public:
      // tolerance
      //
      typedef ::xml_schema::decimal tolerance_type;
      typedef ::xsd::cxx::tree::traits< tolerance_type, char, ::xsd::cxx::tree::schema_type::decimal > tolerance_traits;

      const tolerance_type&
      tolerance () const;

      tolerance_type&
      tolerance ();

      void
      tolerance (const tolerance_type& x);

      static tolerance_type
      tolerance_default_value ();

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      PointWithToleranceAndDescription (const x_type&,
                                        const y_type&,
                                        const z_type&);

      PointWithToleranceAndDescription (const ::xercesc::DOMElement& e,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      PointWithToleranceAndDescription (const PointWithToleranceAndDescription& x,
                                        ::xml_schema::flags f = 0,
                                        ::xml_schema::container* c = 0);

      virtual PointWithToleranceAndDescription*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      PointWithToleranceAndDescription&
      operator= (const PointWithToleranceAndDescription& x);

      virtual 
      ~PointWithToleranceAndDescription ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< tolerance_type > tolerance_;
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class BlockSpecWithDescription: public ::malmo::schemas::BlockSpec
    {
      public:
      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      BlockSpecWithDescription (const type_type&);

      BlockSpecWithDescription (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      BlockSpecWithDescription (const BlockSpecWithDescription& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual BlockSpecWithDescription*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockSpecWithDescription&
      operator= (const BlockSpecWithDescription& x);

      virtual 
      ~BlockSpecWithDescription ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class BlockOrItemSpecWithDescription: public ::malmo::schemas::BlockOrItemSpec
    {
      public:
      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      BlockOrItemSpecWithDescription (const type_type&);

      BlockOrItemSpecWithDescription (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      BlockOrItemSpecWithDescription (const BlockOrItemSpecWithDescription& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual BlockOrItemSpecWithDescription*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BlockOrItemSpecWithDescription&
      operator= (const BlockOrItemSpecWithDescription& x);

      virtual 
      ~BlockOrItemSpecWithDescription ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class MobList: public ::xml_schema::simple_type,
      public ::xsd::cxx::tree::list< ::malmo::schemas::EntityTypes, char >
    {
      public:
      MobList ();

      MobList (size_type n, const ::malmo::schemas::EntityTypes& x);

      template < typename I >
      MobList (const I& begin, const I& end)
      : ::xsd::cxx::tree::list< ::malmo::schemas::EntityTypes, char > (begin, end, this)
      {
      }

      MobList (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      MobList (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      MobList (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      MobList (const MobList& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

      virtual MobList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~MobList ();
    };

    class CommandQuota: public ::xml_schema::type
    {
      public:
      // commands
      //
      typedef ::malmo::schemas::CommandList commands_type;
      typedef ::xsd::cxx::tree::traits< commands_type, char > commands_traits;

      const commands_type&
      commands () const;

      commands_type&
      commands ();

      void
      commands (const commands_type& x);

      void
      commands (::std::auto_ptr< commands_type > p);

      // quota
      //
      typedef ::xml_schema::int_ quota_type;
      typedef ::xsd::cxx::tree::traits< quota_type, char > quota_traits;

      const quota_type&
      quota () const;

      quota_type&
      quota ();

      void
      quota (const quota_type& x);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      CommandQuota (const commands_type&,
                    const quota_type&);

      CommandQuota (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      CommandQuota (const CommandQuota& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual CommandQuota*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      CommandQuota&
      operator= (const CommandQuota& x);

      virtual 
      ~CommandQuota ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< commands_type > commands_;
      ::xsd::cxx::tree::one< quota_type > quota_;
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class yaw: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      yaw (const ::xml_schema::decimal&);

      yaw (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      yaw (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      yaw (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      yaw (const yaw& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      virtual yaw*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~yaw ();
    };

    class pitch: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      pitch (const ::xml_schema::decimal&);

      pitch (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      pitch (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      pitch (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      pitch (const pitch& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

      virtual pitch*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~pitch ();
    };

    class FlatWorldGenerator: public ::xml_schema::type
    {
      public:
      // generatorString
      //
      typedef ::xml_schema::string generatorString_type;
      typedef ::xsd::cxx::tree::traits< generatorString_type, char > generatorString_traits;

      const generatorString_type&
      generatorString () const;

      generatorString_type&
      generatorString ();

      void
      generatorString (const generatorString_type& x);

      void
      generatorString (::std::auto_ptr< generatorString_type > p);

      static const generatorString_type&
      generatorString_default_value ();

      // forceReset
      //
      typedef ::xml_schema::boolean forceReset_type;
      typedef ::xsd::cxx::tree::traits< forceReset_type, char > forceReset_traits;

      const forceReset_type&
      forceReset () const;

      forceReset_type&
      forceReset ();

      void
      forceReset (const forceReset_type& x);

      static forceReset_type
      forceReset_default_value ();

      // seed
      //
      typedef ::xml_schema::string seed_type;
      typedef ::xsd::cxx::tree::traits< seed_type, char > seed_traits;

      const seed_type&
      seed () const;

      seed_type&
      seed ();

      void
      seed (const seed_type& x);

      void
      seed (::std::auto_ptr< seed_type > p);

      static const seed_type&
      seed_default_value ();

      // destroyAfterUse
      //
      typedef ::xml_schema::boolean destroyAfterUse_type;
      typedef ::xsd::cxx::tree::traits< destroyAfterUse_type, char > destroyAfterUse_traits;

      const destroyAfterUse_type&
      destroyAfterUse () const;

      destroyAfterUse_type&
      destroyAfterUse ();

      void
      destroyAfterUse (const destroyAfterUse_type& x);

      static destroyAfterUse_type
      destroyAfterUse_default_value ();

      // Constructors.
      //
      FlatWorldGenerator ();

      FlatWorldGenerator (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FlatWorldGenerator (const FlatWorldGenerator& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FlatWorldGenerator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FlatWorldGenerator&
      operator= (const FlatWorldGenerator& x);

      virtual 
      ~FlatWorldGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< generatorString_type > generatorString_;
      static const generatorString_type generatorString_default_value_;
      ::xsd::cxx::tree::one< forceReset_type > forceReset_;
      ::xsd::cxx::tree::one< seed_type > seed_;
      static const seed_type seed_default_value_;
      ::xsd::cxx::tree::one< destroyAfterUse_type > destroyAfterUse_;
    };

    class DefaultWorldGenerator: public ::xml_schema::type
    {
      public:
      // seed
      //
      typedef ::xml_schema::string seed_type;
      typedef ::xsd::cxx::tree::traits< seed_type, char > seed_traits;

      const seed_type&
      seed () const;

      seed_type&
      seed ();

      void
      seed (const seed_type& x);

      void
      seed (::std::auto_ptr< seed_type > p);

      static const seed_type&
      seed_default_value ();

      // forceReset
      //
      typedef ::xml_schema::boolean forceReset_type;
      typedef ::xsd::cxx::tree::traits< forceReset_type, char > forceReset_traits;

      const forceReset_type&
      forceReset () const;

      forceReset_type&
      forceReset ();

      void
      forceReset (const forceReset_type& x);

      static forceReset_type
      forceReset_default_value ();

      // destroyAfterUse
      //
      typedef ::xml_schema::boolean destroyAfterUse_type;
      typedef ::xsd::cxx::tree::traits< destroyAfterUse_type, char > destroyAfterUse_traits;

      const destroyAfterUse_type&
      destroyAfterUse () const;

      destroyAfterUse_type&
      destroyAfterUse ();

      void
      destroyAfterUse (const destroyAfterUse_type& x);

      static destroyAfterUse_type
      destroyAfterUse_default_value ();

      // Constructors.
      //
      DefaultWorldGenerator ();

      DefaultWorldGenerator (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      DefaultWorldGenerator (const DefaultWorldGenerator& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual DefaultWorldGenerator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DefaultWorldGenerator&
      operator= (const DefaultWorldGenerator& x);

      virtual 
      ~DefaultWorldGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< seed_type > seed_;
      static const seed_type seed_default_value_;
      ::xsd::cxx::tree::one< forceReset_type > forceReset_;
      ::xsd::cxx::tree::one< destroyAfterUse_type > destroyAfterUse_;
    };

    class FileWorldGenerator: public ::xml_schema::type
    {
      public:
      // src
      //
      typedef ::xml_schema::uri src_type;
      typedef ::xsd::cxx::tree::traits< src_type, char > src_traits;

      const src_type&
      src () const;

      src_type&
      src ();

      void
      src (const src_type& x);

      void
      src (::std::auto_ptr< src_type > p);

      // forceReset
      //
      typedef ::xml_schema::boolean forceReset_type;
      typedef ::xsd::cxx::tree::traits< forceReset_type, char > forceReset_traits;

      const forceReset_type&
      forceReset () const;

      forceReset_type&
      forceReset ();

      void
      forceReset (const forceReset_type& x);

      static forceReset_type
      forceReset_default_value ();

      // destroyAfterUse
      //
      typedef ::xml_schema::boolean destroyAfterUse_type;
      typedef ::xsd::cxx::tree::traits< destroyAfterUse_type, char > destroyAfterUse_traits;

      const destroyAfterUse_type&
      destroyAfterUse () const;

      destroyAfterUse_type&
      destroyAfterUse ();

      void
      destroyAfterUse (const destroyAfterUse_type& x);

      static destroyAfterUse_type
      destroyAfterUse_default_value ();

      // Constructors.
      //
      FileWorldGenerator (const src_type&);

      FileWorldGenerator (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      FileWorldGenerator (const FileWorldGenerator& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual FileWorldGenerator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      FileWorldGenerator&
      operator= (const FileWorldGenerator& x);

      virtual 
      ~FileWorldGenerator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< src_type > src_;
      ::xsd::cxx::tree::one< forceReset_type > forceReset_;
      ::xsd::cxx::tree::one< destroyAfterUse_type > destroyAfterUse_;
    };

    class MovingTargetDecorator: public ::xml_schema::type
    {
      public:
      // ArenaBounds
      //
      typedef ::malmo::schemas::UnnamedGridDefinition ArenaBounds_type;
      typedef ::xsd::cxx::tree::traits< ArenaBounds_type, char > ArenaBounds_traits;

      const ArenaBounds_type&
      ArenaBounds () const;

      ArenaBounds_type&
      ArenaBounds ();

      void
      ArenaBounds (const ArenaBounds_type& x);

      void
      ArenaBounds (::std::auto_ptr< ArenaBounds_type > p);

      // StartPos
      //
      typedef ::malmo::schemas::Pos StartPos_type;
      typedef ::xsd::cxx::tree::traits< StartPos_type, char > StartPos_traits;

      const StartPos_type&
      StartPos () const;

      StartPos_type&
      StartPos ();

      void
      StartPos (const StartPos_type& x);

      void
      StartPos (::std::auto_ptr< StartPos_type > p);

      // Seed
      //
      typedef ::malmo::schemas::Seed Seed_type;
      typedef ::xsd::cxx::tree::traits< Seed_type, char > Seed_traits;

      const Seed_type&
      Seed () const;

      Seed_type&
      Seed ();

      void
      Seed (const Seed_type& x);

      void
      Seed (::std::auto_ptr< Seed_type > p);

      // UpdateSpeed
      //
      typedef ::malmo::schemas::UpdateSpeed UpdateSpeed_type;
      typedef ::xsd::cxx::tree::traits< UpdateSpeed_type, char > UpdateSpeed_traits;

      const UpdateSpeed_type&
      UpdateSpeed () const;

      UpdateSpeed_type&
      UpdateSpeed ();

      void
      UpdateSpeed (const UpdateSpeed_type& x);

      void
      UpdateSpeed (::std::auto_ptr< UpdateSpeed_type > p);

      // PermeableBlocks
      //
      typedef ::malmo::schemas::BlockSpec PermeableBlocks_type;
      typedef ::xsd::cxx::tree::traits< PermeableBlocks_type, char > PermeableBlocks_traits;

      const PermeableBlocks_type&
      PermeableBlocks () const;

      PermeableBlocks_type&
      PermeableBlocks ();

      void
      PermeableBlocks (const PermeableBlocks_type& x);

      void
      PermeableBlocks (::std::auto_ptr< PermeableBlocks_type > p);

      // BlockType
      //
      typedef ::malmo::schemas::DrawBlockBasedObjectType BlockType_type;
      typedef ::xsd::cxx::tree::traits< BlockType_type, char > BlockType_traits;

      const BlockType_type&
      BlockType () const;

      BlockType_type&
      BlockType ();

      void
      BlockType (const BlockType_type& x);

      void
      BlockType (::std::auto_ptr< BlockType_type > p);

      // requiresAirAbove
      //
      typedef ::xml_schema::boolean requiresAirAbove_type;
      typedef ::xsd::cxx::tree::traits< requiresAirAbove_type, char > requiresAirAbove_traits;

      const requiresAirAbove_type&
      requiresAirAbove () const;

      requiresAirAbove_type&
      requiresAirAbove ();

      void
      requiresAirAbove (const requiresAirAbove_type& x);

      static requiresAirAbove_type
      requiresAirAbove_default_value ();

      // Constructors.
      //
      MovingTargetDecorator (const ArenaBounds_type&,
                             const StartPos_type&,
                             const Seed_type&,
                             const UpdateSpeed_type&,
                             const PermeableBlocks_type&,
                             const BlockType_type&);

      MovingTargetDecorator (::std::auto_ptr< ArenaBounds_type >,
                             ::std::auto_ptr< StartPos_type >,
                             const Seed_type&,
                             const UpdateSpeed_type&,
                             ::std::auto_ptr< PermeableBlocks_type >,
                             ::std::auto_ptr< BlockType_type >);

      MovingTargetDecorator (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      MovingTargetDecorator (const MovingTargetDecorator& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual MovingTargetDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MovingTargetDecorator&
      operator= (const MovingTargetDecorator& x);

      virtual 
      ~MovingTargetDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< ArenaBounds_type > ArenaBounds_;
      ::xsd::cxx::tree::one< StartPos_type > StartPos_;
      ::xsd::cxx::tree::one< Seed_type > Seed_;
      ::xsd::cxx::tree::one< UpdateSpeed_type > UpdateSpeed_;
      ::xsd::cxx::tree::one< PermeableBlocks_type > PermeableBlocks_;
      ::xsd::cxx::tree::one< BlockType_type > BlockType_;
      ::xsd::cxx::tree::one< requiresAirAbove_type > requiresAirAbove_;
    };

    class SnakeDecorator: public ::xml_schema::type
    {
      public:
      // Seed
      //
      typedef ::malmo::schemas::Seed Seed_type;
      typedef ::xsd::cxx::tree::traits< Seed_type, char > Seed_traits;

      const Seed_type&
      Seed () const;

      Seed_type&
      Seed ();

      void
      Seed (const Seed_type& x);

      void
      Seed (::std::auto_ptr< Seed_type > p);

      // MaterialSeed
      //
      typedef ::malmo::schemas::MaterialSeed MaterialSeed_type;
      typedef ::xsd::cxx::tree::optional< MaterialSeed_type > MaterialSeed_optional;
      typedef ::xsd::cxx::tree::traits< MaterialSeed_type, char > MaterialSeed_traits;

      const MaterialSeed_optional&
      MaterialSeed () const;

      MaterialSeed_optional&
      MaterialSeed ();

      void
      MaterialSeed (const MaterialSeed_type& x);

      void
      MaterialSeed (const MaterialSeed_optional& x);

      void
      MaterialSeed (::std::auto_ptr< MaterialSeed_type > p);

      // FreshBlock
      //
      typedef ::malmo::schemas::SnakeBlock FreshBlock_type;
      typedef ::xsd::cxx::tree::traits< FreshBlock_type, char > FreshBlock_traits;

      const FreshBlock_type&
      FreshBlock () const;

      FreshBlock_type&
      FreshBlock ();

      void
      FreshBlock (const FreshBlock_type& x);

      void
      FreshBlock (::std::auto_ptr< FreshBlock_type > p);

      // StaleBlock
      //
      typedef ::malmo::schemas::SnakeBlock StaleBlock_type;
      typedef ::xsd::cxx::tree::traits< StaleBlock_type, char > StaleBlock_traits;

      const StaleBlock_type&
      StaleBlock () const;

      StaleBlock_type&
      StaleBlock ();

      void
      StaleBlock (const StaleBlock_type& x);

      void
      StaleBlock (::std::auto_ptr< StaleBlock_type > p);

      // GapProbability
      //
      typedef ::malmo::schemas::GapProbability GapProbability_type;
      typedef ::xsd::cxx::tree::traits< GapProbability_type, char > GapProbability_traits;

      const GapProbability_type&
      GapProbability () const;

      GapProbability_type&
      GapProbability ();

      void
      GapProbability (const GapProbability_type& x);

      void
      GapProbability (::std::auto_ptr< GapProbability_type > p);

      // StairsProbability
      //
      typedef ::malmo::schemas::StairsProbability StairsProbability_type;
      typedef ::xsd::cxx::tree::traits< StairsProbability_type, char > StairsProbability_traits;

      const StairsProbability_type&
      StairsProbability () const;

      StairsProbability_type&
      StairsProbability ();

      void
      StairsProbability (const StairsProbability_type& x);

      void
      StairsProbability (::std::auto_ptr< StairsProbability_type > p);

      // TurnProbability
      //
      typedef ::malmo::schemas::TurnProbability TurnProbability_type;
      typedef ::xsd::cxx::tree::traits< TurnProbability_type, char > TurnProbability_traits;

      const TurnProbability_type&
      TurnProbability () const;

      TurnProbability_type&
      TurnProbability ();

      void
      TurnProbability (const TurnProbability_type& x);

      void
      TurnProbability (::std::auto_ptr< TurnProbability_type > p);

      // SizeAndPosition
      //
      typedef ::malmo::schemas::SizeAndPosition SizeAndPosition_type;
      typedef ::xsd::cxx::tree::traits< SizeAndPosition_type, char > SizeAndPosition_traits;

      const SizeAndPosition_type&
      SizeAndPosition () const;

      SizeAndPosition_type&
      SizeAndPosition ();

      void
      SizeAndPosition (const SizeAndPosition_type& x);

      void
      SizeAndPosition (::std::auto_ptr< SizeAndPosition_type > p);

      // SpeedInTicks
      //
      typedef ::xml_schema::int_ SpeedInTicks_type;
      typedef ::xsd::cxx::tree::traits< SpeedInTicks_type, char > SpeedInTicks_traits;

      const SpeedInTicks_type&
      SpeedInTicks () const;

      SpeedInTicks_type&
      SpeedInTicks ();

      void
      SpeedInTicks (const SpeedInTicks_type& x);

      static SpeedInTicks_type
      SpeedInTicks_default_value ();

      // MaxLength
      //
      typedef ::xml_schema::int_ MaxLength_type;
      typedef ::xsd::cxx::tree::traits< MaxLength_type, char > MaxLength_traits;

      const MaxLength_type&
      MaxLength () const;

      MaxLength_type&
      MaxLength ();

      void
      MaxLength (const MaxLength_type& x);

      static MaxLength_type
      MaxLength_default_value ();

      // MaxStairLength
      //
      typedef ::xml_schema::int_ MaxStairLength_type;
      typedef ::xsd::cxx::tree::traits< MaxStairLength_type, char > MaxStairLength_traits;

      const MaxStairLength_type&
      MaxStairLength () const;

      MaxStairLength_type&
      MaxStairLength ();

      void
      MaxStairLength (const MaxStairLength_type& x);

      static MaxStairLength_type
      MaxStairLength_default_value ();

      // Constructors.
      //
      SnakeDecorator (const Seed_type&,
                      const FreshBlock_type&,
                      const StaleBlock_type&,
                      const GapProbability_type&,
                      const StairsProbability_type&,
                      const TurnProbability_type&,
                      const SizeAndPosition_type&,
                      const SpeedInTicks_type&,
                      const MaxLength_type&,
                      const MaxStairLength_type&);

      SnakeDecorator (const Seed_type&,
                      ::std::auto_ptr< FreshBlock_type >,
                      ::std::auto_ptr< StaleBlock_type >,
                      ::std::auto_ptr< GapProbability_type >,
                      ::std::auto_ptr< StairsProbability_type >,
                      ::std::auto_ptr< TurnProbability_type >,
                      ::std::auto_ptr< SizeAndPosition_type >,
                      const SpeedInTicks_type&,
                      const MaxLength_type&,
                      const MaxStairLength_type&);

      SnakeDecorator (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      SnakeDecorator (const SnakeDecorator& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual SnakeDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SnakeDecorator&
      operator= (const SnakeDecorator& x);

      virtual 
      ~SnakeDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Seed_type > Seed_;
      MaterialSeed_optional MaterialSeed_;
      ::xsd::cxx::tree::one< FreshBlock_type > FreshBlock_;
      ::xsd::cxx::tree::one< StaleBlock_type > StaleBlock_;
      ::xsd::cxx::tree::one< GapProbability_type > GapProbability_;
      ::xsd::cxx::tree::one< StairsProbability_type > StairsProbability_;
      ::xsd::cxx::tree::one< TurnProbability_type > TurnProbability_;
      ::xsd::cxx::tree::one< SizeAndPosition_type > SizeAndPosition_;
      ::xsd::cxx::tree::one< SpeedInTicks_type > SpeedInTicks_;
      ::xsd::cxx::tree::one< MaxLength_type > MaxLength_;
      ::xsd::cxx::tree::one< MaxStairLength_type > MaxStairLength_;
    };

    class MazeDecorator: public ::xml_schema::type
    {
      public:
      // Seed
      //
      typedef ::malmo::schemas::Seed Seed_type;
      typedef ::xsd::cxx::tree::traits< Seed_type, char > Seed_traits;

      const Seed_type&
      Seed () const;

      Seed_type&
      Seed ();

      void
      Seed (const Seed_type& x);

      void
      Seed (::std::auto_ptr< Seed_type > p);

      // MaterialSeed
      //
      typedef ::malmo::schemas::MaterialSeed MaterialSeed_type;
      typedef ::xsd::cxx::tree::optional< MaterialSeed_type > MaterialSeed_optional;
      typedef ::xsd::cxx::tree::traits< MaterialSeed_type, char > MaterialSeed_traits;

      const MaterialSeed_optional&
      MaterialSeed () const;

      MaterialSeed_optional&
      MaterialSeed ();

      void
      MaterialSeed (const MaterialSeed_type& x);

      void
      MaterialSeed (const MaterialSeed_optional& x);

      void
      MaterialSeed (::std::auto_ptr< MaterialSeed_type > p);

      // AllowDiagonalMovement
      //
      typedef ::xml_schema::boolean AllowDiagonalMovement_type;
      typedef ::xsd::cxx::tree::traits< AllowDiagonalMovement_type, char > AllowDiagonalMovement_traits;

      const AllowDiagonalMovement_type&
      AllowDiagonalMovement () const;

      AllowDiagonalMovement_type&
      AllowDiagonalMovement ();

      void
      AllowDiagonalMovement (const AllowDiagonalMovement_type& x);

      static AllowDiagonalMovement_type
      AllowDiagonalMovement_default_value ();

      // SizeAndPosition
      //
      typedef ::malmo::schemas::SizeAndPosition1 SizeAndPosition_type;
      typedef ::xsd::cxx::tree::traits< SizeAndPosition_type, char > SizeAndPosition_traits;

      const SizeAndPosition_type&
      SizeAndPosition () const;

      SizeAndPosition_type&
      SizeAndPosition ();

      void
      SizeAndPosition (const SizeAndPosition_type& x);

      void
      SizeAndPosition (::std::auto_ptr< SizeAndPosition_type > p);

      // StartBlock
      //
      typedef ::malmo::schemas::MazeTerminus StartBlock_type;
      typedef ::xsd::cxx::tree::traits< StartBlock_type, char > StartBlock_traits;

      const StartBlock_type&
      StartBlock () const;

      StartBlock_type&
      StartBlock ();

      void
      StartBlock (const StartBlock_type& x);

      void
      StartBlock (::std::auto_ptr< StartBlock_type > p);

      // EndBlock
      //
      typedef ::malmo::schemas::MazeTerminus EndBlock_type;
      typedef ::xsd::cxx::tree::traits< EndBlock_type, char > EndBlock_traits;

      const EndBlock_type&
      EndBlock () const;

      EndBlock_type&
      EndBlock ();

      void
      EndBlock (const EndBlock_type& x);

      void
      EndBlock (::std::auto_ptr< EndBlock_type > p);

      // PathBlock
      //
      typedef ::malmo::schemas::MazeBlock PathBlock_type;
      typedef ::xsd::cxx::tree::traits< PathBlock_type, char > PathBlock_traits;

      const PathBlock_type&
      PathBlock () const;

      PathBlock_type&
      PathBlock ();

      void
      PathBlock (const PathBlock_type& x);

      void
      PathBlock (::std::auto_ptr< PathBlock_type > p);

      // FloorBlock
      //
      typedef ::malmo::schemas::MazeBlock FloorBlock_type;
      typedef ::xsd::cxx::tree::traits< FloorBlock_type, char > FloorBlock_traits;

      const FloorBlock_type&
      FloorBlock () const;

      FloorBlock_type&
      FloorBlock ();

      void
      FloorBlock (const FloorBlock_type& x);

      void
      FloorBlock (::std::auto_ptr< FloorBlock_type > p);

      // GapBlock
      //
      typedef ::malmo::schemas::MazeBlock GapBlock_type;
      typedef ::xsd::cxx::tree::traits< GapBlock_type, char > GapBlock_traits;

      const GapBlock_type&
      GapBlock () const;

      GapBlock_type&
      GapBlock ();

      void
      GapBlock (const GapBlock_type& x);

      void
      GapBlock (::std::auto_ptr< GapBlock_type > p);

      // OptimalPathBlock
      //
      typedef ::malmo::schemas::MazeBlock OptimalPathBlock_type;
      typedef ::xsd::cxx::tree::optional< OptimalPathBlock_type > OptimalPathBlock_optional;
      typedef ::xsd::cxx::tree::traits< OptimalPathBlock_type, char > OptimalPathBlock_traits;

      const OptimalPathBlock_optional&
      OptimalPathBlock () const;

      OptimalPathBlock_optional&
      OptimalPathBlock ();

      void
      OptimalPathBlock (const OptimalPathBlock_type& x);

      void
      OptimalPathBlock (const OptimalPathBlock_optional& x);

      void
      OptimalPathBlock (::std::auto_ptr< OptimalPathBlock_type > p);

      // SubgoalBlock
      //
      typedef ::malmo::schemas::MazeBlock SubgoalBlock_type;
      typedef ::xsd::cxx::tree::optional< SubgoalBlock_type > SubgoalBlock_optional;
      typedef ::xsd::cxx::tree::traits< SubgoalBlock_type, char > SubgoalBlock_traits;

      const SubgoalBlock_optional&
      SubgoalBlock () const;

      SubgoalBlock_optional&
      SubgoalBlock ();

      void
      SubgoalBlock (const SubgoalBlock_type& x);

      void
      SubgoalBlock (const SubgoalBlock_optional& x);

      void
      SubgoalBlock (::std::auto_ptr< SubgoalBlock_type > p);

      // Waypoints
      //
      typedef ::malmo::schemas::Waypoints Waypoints_type;
      typedef ::xsd::cxx::tree::optional< Waypoints_type > Waypoints_optional;
      typedef ::xsd::cxx::tree::traits< Waypoints_type, char > Waypoints_traits;

      const Waypoints_optional&
      Waypoints () const;

      Waypoints_optional&
      Waypoints ();

      void
      Waypoints (const Waypoints_type& x);

      void
      Waypoints (const Waypoints_optional& x);

      void
      Waypoints (::std::auto_ptr< Waypoints_type > p);

      // GapProbability
      //
      typedef ::malmo::schemas::GapProbability GapProbability_type;
      typedef ::xsd::cxx::tree::traits< GapProbability_type, char > GapProbability_traits;

      const GapProbability_type&
      GapProbability () const;

      GapProbability_type&
      GapProbability ();

      void
      GapProbability (const GapProbability_type& x);

      void
      GapProbability (::std::auto_ptr< GapProbability_type > p);

      // AddQuitProducer
      //
      typedef ::malmo::schemas::AddQuitProducer AddQuitProducer_type;
      typedef ::xsd::cxx::tree::optional< AddQuitProducer_type > AddQuitProducer_optional;
      typedef ::xsd::cxx::tree::traits< AddQuitProducer_type, char > AddQuitProducer_traits;

      const AddQuitProducer_optional&
      AddQuitProducer () const;

      AddQuitProducer_optional&
      AddQuitProducer ();

      void
      AddQuitProducer (const AddQuitProducer_type& x);

      void
      AddQuitProducer (const AddQuitProducer_optional& x);

      void
      AddQuitProducer (::std::auto_ptr< AddQuitProducer_type > p);

      // AddNavigationObservations
      //
      typedef ::malmo::schemas::AddNavigationObservations AddNavigationObservations_type;
      typedef ::xsd::cxx::tree::optional< AddNavigationObservations_type > AddNavigationObservations_optional;
      typedef ::xsd::cxx::tree::traits< AddNavigationObservations_type, char > AddNavigationObservations_traits;

      const AddNavigationObservations_optional&
      AddNavigationObservations () const;

      AddNavigationObservations_optional&
      AddNavigationObservations ();

      void
      AddNavigationObservations (const AddNavigationObservations_type& x);

      void
      AddNavigationObservations (const AddNavigationObservations_optional& x);

      void
      AddNavigationObservations (::std::auto_ptr< AddNavigationObservations_type > p);

      // Constructors.
      //
      MazeDecorator (const Seed_type&,
                     const AllowDiagonalMovement_type&,
                     const SizeAndPosition_type&,
                     const StartBlock_type&,
                     const EndBlock_type&,
                     const PathBlock_type&,
                     const FloorBlock_type&,
                     const GapBlock_type&,
                     const GapProbability_type&);

      MazeDecorator (const Seed_type&,
                     const AllowDiagonalMovement_type&,
                     ::std::auto_ptr< SizeAndPosition_type >,
                     ::std::auto_ptr< StartBlock_type >,
                     ::std::auto_ptr< EndBlock_type >,
                     ::std::auto_ptr< PathBlock_type >,
                     ::std::auto_ptr< FloorBlock_type >,
                     ::std::auto_ptr< GapBlock_type >,
                     ::std::auto_ptr< GapProbability_type >);

      MazeDecorator (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      MazeDecorator (const MazeDecorator& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual MazeDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MazeDecorator&
      operator= (const MazeDecorator& x);

      virtual 
      ~MazeDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Seed_type > Seed_;
      MaterialSeed_optional MaterialSeed_;
      ::xsd::cxx::tree::one< AllowDiagonalMovement_type > AllowDiagonalMovement_;
      ::xsd::cxx::tree::one< SizeAndPosition_type > SizeAndPosition_;
      ::xsd::cxx::tree::one< StartBlock_type > StartBlock_;
      ::xsd::cxx::tree::one< EndBlock_type > EndBlock_;
      ::xsd::cxx::tree::one< PathBlock_type > PathBlock_;
      ::xsd::cxx::tree::one< FloorBlock_type > FloorBlock_;
      ::xsd::cxx::tree::one< GapBlock_type > GapBlock_;
      OptimalPathBlock_optional OptimalPathBlock_;
      SubgoalBlock_optional SubgoalBlock_;
      Waypoints_optional Waypoints_;
      ::xsd::cxx::tree::one< GapProbability_type > GapProbability_;
      AddQuitProducer_optional AddQuitProducer_;
      AddNavigationObservations_optional AddNavigationObservations_;
    };

    class DrawingDecorator: public ::xml_schema::type
    {
      public:
      // DrawObjectType
      //
      typedef ::malmo::schemas::DrawObjectType DrawObjectType_type;
      typedef ::xsd::cxx::tree::sequence< DrawObjectType_type > DrawObjectType_sequence;
      typedef DrawObjectType_sequence::iterator DrawObjectType_iterator;
      typedef DrawObjectType_sequence::const_iterator DrawObjectType_const_iterator;
      typedef ::xsd::cxx::tree::traits< DrawObjectType_type, char > DrawObjectType_traits;

      const DrawObjectType_sequence&
      DrawObjectType () const;

      DrawObjectType_sequence&
      DrawObjectType ();

      void
      DrawObjectType (const DrawObjectType_sequence& s);

      // Constructors.
      //
      DrawingDecorator ();

      DrawingDecorator (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      DrawingDecorator (const DrawingDecorator& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual DrawingDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DrawingDecorator&
      operator= (const DrawingDecorator& x);

      virtual 
      ~DrawingDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      DrawObjectType_sequence DrawObjectType_;
    };

    class ClassroomDecorator: public ::xml_schema::type
    {
      public:
      // complexity
      //
      typedef ::malmo::schemas::complexity complexity_type;
      typedef ::xsd::cxx::tree::optional< complexity_type > complexity_optional;
      typedef ::xsd::cxx::tree::traits< complexity_type, char > complexity_traits;

      const complexity_optional&
      complexity () const;

      complexity_optional&
      complexity ();

      void
      complexity (const complexity_type& x);

      void
      complexity (const complexity_optional& x);

      void
      complexity (::std::auto_ptr< complexity_type > p);

      // specification
      //
      typedef ::malmo::schemas::specification specification_type;
      typedef ::xsd::cxx::tree::optional< specification_type > specification_optional;
      typedef ::xsd::cxx::tree::traits< specification_type, char > specification_traits;

      const specification_optional&
      specification () const;

      specification_optional&
      specification ();

      void
      specification (const specification_type& x);

      void
      specification (const specification_optional& x);

      void
      specification (::std::auto_ptr< specification_type > p);

      // seed
      //
      typedef ::xml_schema::string seed_type;
      typedef ::xsd::cxx::tree::optional< seed_type > seed_optional;
      typedef ::xsd::cxx::tree::traits< seed_type, char > seed_traits;

      const seed_optional&
      seed () const;

      seed_optional&
      seed ();

      void
      seed (const seed_type& x);

      void
      seed (const seed_optional& x);

      void
      seed (::std::auto_ptr< seed_type > p);

      // palette
      //
      typedef ::malmo::schemas::PaletteEnum palette_type;
      typedef ::xsd::cxx::tree::optional< palette_type > palette_optional;
      typedef ::xsd::cxx::tree::traits< palette_type, char > palette_traits;

      const palette_optional&
      palette () const;

      palette_optional&
      palette ();

      void
      palette (const palette_type& x);

      void
      palette (const palette_optional& x);

      void
      palette (::std::auto_ptr< palette_type > p);

      // Constructors.
      //
      ClassroomDecorator ();

      ClassroomDecorator (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ClassroomDecorator (const ClassroomDecorator& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ClassroomDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ClassroomDecorator&
      operator= (const ClassroomDecorator& x);

      virtual 
      ~ClassroomDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      complexity_optional complexity_;
      specification_optional specification_;
      seed_optional seed_;
      palette_optional palette_;
    };

    class AnimationDecorator: public ::xml_schema::type
    {
      public:
      // Parametric
      //
      typedef ::malmo::schemas::Parametric Parametric_type;
      typedef ::xsd::cxx::tree::optional< Parametric_type > Parametric_optional;
      typedef ::xsd::cxx::tree::traits< Parametric_type, char > Parametric_traits;

      const Parametric_optional&
      Parametric () const;

      Parametric_optional&
      Parametric ();

      void
      Parametric (const Parametric_type& x);

      void
      Parametric (const Parametric_optional& x);

      void
      Parametric (::std::auto_ptr< Parametric_type > p);

      // Linear
      //
      typedef ::malmo::schemas::Linear Linear_type;
      typedef ::xsd::cxx::tree::optional< Linear_type > Linear_optional;
      typedef ::xsd::cxx::tree::traits< Linear_type, char > Linear_traits;

      const Linear_optional&
      Linear () const;

      Linear_optional&
      Linear ();

      void
      Linear (const Linear_type& x);

      void
      Linear (const Linear_optional& x);

      void
      Linear (::std::auto_ptr< Linear_type > p);

      // DrawingDecorator
      //
      typedef ::malmo::schemas::DrawingDecorator DrawingDecorator_type;
      typedef ::xsd::cxx::tree::traits< DrawingDecorator_type, char > DrawingDecorator_traits;

      const DrawingDecorator_type&
      DrawingDecorator () const;

      DrawingDecorator_type&
      DrawingDecorator ();

      void
      DrawingDecorator (const DrawingDecorator_type& x);

      void
      DrawingDecorator (::std::auto_ptr< DrawingDecorator_type > p);

      // ticksPerUpdate
      //
      typedef ::xml_schema::int_ ticksPerUpdate_type;
      typedef ::xsd::cxx::tree::traits< ticksPerUpdate_type, char > ticksPerUpdate_traits;

      const ticksPerUpdate_type&
      ticksPerUpdate () const;

      ticksPerUpdate_type&
      ticksPerUpdate ();

      void
      ticksPerUpdate (const ticksPerUpdate_type& x);

      static ticksPerUpdate_type
      ticksPerUpdate_default_value ();

      // Constructors.
      //
      AnimationDecorator (const DrawingDecorator_type&);

      AnimationDecorator (::std::auto_ptr< DrawingDecorator_type >);

      AnimationDecorator (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      AnimationDecorator (const AnimationDecorator& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual AnimationDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AnimationDecorator&
      operator= (const AnimationDecorator& x);

      virtual 
      ~AnimationDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Parametric_optional Parametric_;
      Linear_optional Linear_;
      ::xsd::cxx::tree::one< DrawingDecorator_type > DrawingDecorator_;
      ::xsd::cxx::tree::one< ticksPerUpdate_type > ticksPerUpdate_;
    };

    class BuildBattleDecorator: public ::xml_schema::type
    {
      public:
      // GoalStructureBounds
      //
      typedef ::malmo::schemas::UnnamedGridDefinition GoalStructureBounds_type;
      typedef ::xsd::cxx::tree::traits< GoalStructureBounds_type, char > GoalStructureBounds_traits;

      const GoalStructureBounds_type&
      GoalStructureBounds () const;

      GoalStructureBounds_type&
      GoalStructureBounds ();

      void
      GoalStructureBounds (const GoalStructureBounds_type& x);

      void
      GoalStructureBounds (::std::auto_ptr< GoalStructureBounds_type > p);

      // PlayerStructureBounds
      //
      typedef ::malmo::schemas::UnnamedGridDefinition PlayerStructureBounds_type;
      typedef ::xsd::cxx::tree::traits< PlayerStructureBounds_type, char > PlayerStructureBounds_traits;

      const PlayerStructureBounds_type&
      PlayerStructureBounds () const;

      PlayerStructureBounds_type&
      PlayerStructureBounds ();

      void
      PlayerStructureBounds (const PlayerStructureBounds_type& x);

      void
      PlayerStructureBounds (::std::auto_ptr< PlayerStructureBounds_type > p);

      // BlockTypeOnCorrectPlacement
      //
      typedef ::malmo::schemas::DrawBlockBasedObjectType BlockTypeOnCorrectPlacement_type;
      typedef ::xsd::cxx::tree::optional< BlockTypeOnCorrectPlacement_type > BlockTypeOnCorrectPlacement_optional;
      typedef ::xsd::cxx::tree::traits< BlockTypeOnCorrectPlacement_type, char > BlockTypeOnCorrectPlacement_traits;

      const BlockTypeOnCorrectPlacement_optional&
      BlockTypeOnCorrectPlacement () const;

      BlockTypeOnCorrectPlacement_optional&
      BlockTypeOnCorrectPlacement ();

      void
      BlockTypeOnCorrectPlacement (const BlockTypeOnCorrectPlacement_type& x);

      void
      BlockTypeOnCorrectPlacement (const BlockTypeOnCorrectPlacement_optional& x);

      void
      BlockTypeOnCorrectPlacement (::std::auto_ptr< BlockTypeOnCorrectPlacement_type > p);

      // BlockTypeOnIncorrectPlacement
      //
      typedef ::malmo::schemas::DrawBlockBasedObjectType BlockTypeOnIncorrectPlacement_type;
      typedef ::xsd::cxx::tree::optional< BlockTypeOnIncorrectPlacement_type > BlockTypeOnIncorrectPlacement_optional;
      typedef ::xsd::cxx::tree::traits< BlockTypeOnIncorrectPlacement_type, char > BlockTypeOnIncorrectPlacement_traits;

      const BlockTypeOnIncorrectPlacement_optional&
      BlockTypeOnIncorrectPlacement () const;

      BlockTypeOnIncorrectPlacement_optional&
      BlockTypeOnIncorrectPlacement ();

      void
      BlockTypeOnIncorrectPlacement (const BlockTypeOnIncorrectPlacement_type& x);

      void
      BlockTypeOnIncorrectPlacement (const BlockTypeOnIncorrectPlacement_optional& x);

      void
      BlockTypeOnIncorrectPlacement (::std::auto_ptr< BlockTypeOnIncorrectPlacement_type > p);

      // Constructors.
      //
      BuildBattleDecorator (const GoalStructureBounds_type&,
                            const PlayerStructureBounds_type&);

      BuildBattleDecorator (::std::auto_ptr< GoalStructureBounds_type >,
                            ::std::auto_ptr< PlayerStructureBounds_type >);

      BuildBattleDecorator (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      BuildBattleDecorator (const BuildBattleDecorator& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual BuildBattleDecorator*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      BuildBattleDecorator&
      operator= (const BuildBattleDecorator& x);

      virtual 
      ~BuildBattleDecorator ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< GoalStructureBounds_type > GoalStructureBounds_;
      ::xsd::cxx::tree::one< PlayerStructureBounds_type > PlayerStructureBounds_;
      BlockTypeOnCorrectPlacement_optional BlockTypeOnCorrectPlacement_;
      BlockTypeOnIncorrectPlacement_optional BlockTypeOnIncorrectPlacement_;
    };

    class ServerQuitFromTimeUp: public ::xml_schema::type
    {
      public:
      // timeLimitMs
      //
      typedef ::xml_schema::decimal timeLimitMs_type;
      typedef ::xsd::cxx::tree::traits< timeLimitMs_type, char, ::xsd::cxx::tree::schema_type::decimal > timeLimitMs_traits;

      const timeLimitMs_type&
      timeLimitMs () const;

      timeLimitMs_type&
      timeLimitMs ();

      void
      timeLimitMs (const timeLimitMs_type& x);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      ServerQuitFromTimeUp (const timeLimitMs_type&);

      ServerQuitFromTimeUp (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      ServerQuitFromTimeUp (const ServerQuitFromTimeUp& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual ServerQuitFromTimeUp*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ServerQuitFromTimeUp&
      operator= (const ServerQuitFromTimeUp& x);

      virtual 
      ~ServerQuitFromTimeUp ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< timeLimitMs_type > timeLimitMs_;
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class ServerQuitWhenAnyAgentFinishes: public ::xml_schema::type
    {
      public:
      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      ServerQuitWhenAnyAgentFinishes ();

      ServerQuitWhenAnyAgentFinishes (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      ServerQuitWhenAnyAgentFinishes (const ServerQuitWhenAnyAgentFinishes& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual ServerQuitWhenAnyAgentFinishes*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ServerQuitWhenAnyAgentFinishes&
      operator= (const ServerQuitWhenAnyAgentFinishes& x);

      virtual 
      ~ServerQuitWhenAnyAgentFinishes ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class DepthProducer: public ::xml_schema::type
    {
      public:
      // Width
      //
      typedef ::xml_schema::int_ Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, char > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      // Height
      //
      typedef ::xml_schema::int_ Height_type;
      typedef ::xsd::cxx::tree::traits< Height_type, char > Height_traits;

      const Height_type&
      Height () const;

      Height_type&
      Height ();

      void
      Height (const Height_type& x);

      // Constructors.
      //
      DepthProducer (const Width_type&,
                     const Height_type&);

      DepthProducer (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      DepthProducer (const DepthProducer& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual DepthProducer*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DepthProducer&
      operator= (const DepthProducer& x);

      virtual 
      ~DepthProducer ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Width_type > Width_;
      ::xsd::cxx::tree::one< Height_type > Height_;
    };

    class LuminanceProducer: public ::xml_schema::type
    {
      public:
      // Width
      //
      typedef ::xml_schema::int_ Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, char > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      // Height
      //
      typedef ::xml_schema::int_ Height_type;
      typedef ::xsd::cxx::tree::traits< Height_type, char > Height_traits;

      const Height_type&
      Height () const;

      Height_type&
      Height ();

      void
      Height (const Height_type& x);

      // Constructors.
      //
      LuminanceProducer (const Width_type&,
                         const Height_type&);

      LuminanceProducer (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      LuminanceProducer (const LuminanceProducer& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual LuminanceProducer*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      LuminanceProducer&
      operator= (const LuminanceProducer& x);

      virtual 
      ~LuminanceProducer ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Width_type > Width_;
      ::xsd::cxx::tree::one< Height_type > Height_;
    };

    class ColourMapProducer: public ::xml_schema::type
    {
      public:
      // Width
      //
      typedef ::xml_schema::int_ Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, char > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      // Height
      //
      typedef ::xml_schema::int_ Height_type;
      typedef ::xsd::cxx::tree::traits< Height_type, char > Height_traits;

      const Height_type&
      Height () const;

      Height_type&
      Height ();

      void
      Height (const Height_type& x);

      // ColourSpec
      //
      typedef ::malmo::schemas::MobWithColour ColourSpec_type;
      typedef ::xsd::cxx::tree::sequence< ColourSpec_type > ColourSpec_sequence;
      typedef ColourSpec_sequence::iterator ColourSpec_iterator;
      typedef ColourSpec_sequence::const_iterator ColourSpec_const_iterator;
      typedef ::xsd::cxx::tree::traits< ColourSpec_type, char > ColourSpec_traits;

      const ColourSpec_sequence&
      ColourSpec () const;

      ColourSpec_sequence&
      ColourSpec ();

      void
      ColourSpec (const ColourSpec_sequence& s);

      // skyColour
      //
      typedef ::malmo::schemas::HexColour skyColour_type;
      typedef ::xsd::cxx::tree::traits< skyColour_type, char > skyColour_traits;

      const skyColour_type&
      skyColour () const;

      skyColour_type&
      skyColour ();

      void
      skyColour (const skyColour_type& x);

      void
      skyColour (::std::auto_ptr< skyColour_type > p);

      static const skyColour_type&
      skyColour_default_value ();

      // Constructors.
      //
      ColourMapProducer (const Width_type&,
                         const Height_type&);

      ColourMapProducer (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      ColourMapProducer (const ColourMapProducer& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual ColourMapProducer*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ColourMapProducer&
      operator= (const ColourMapProducer& x);

      virtual 
      ~ColourMapProducer ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Width_type > Width_;
      ::xsd::cxx::tree::one< Height_type > Height_;
      ColourSpec_sequence ColourSpec_;
      ::xsd::cxx::tree::one< skyColour_type > skyColour_;
      static const skyColour_type skyColour_default_value_;
    };

    class VideoProducer: public ::xml_schema::type
    {
      public:
      // Width
      //
      typedef ::xml_schema::int_ Width_type;
      typedef ::xsd::cxx::tree::traits< Width_type, char > Width_traits;

      const Width_type&
      Width () const;

      Width_type&
      Width ();

      void
      Width (const Width_type& x);

      // Height
      //
      typedef ::xml_schema::int_ Height_type;
      typedef ::xsd::cxx::tree::traits< Height_type, char > Height_traits;

      const Height_type&
      Height () const;

      Height_type&
      Height ();

      void
      Height (const Height_type& x);

      // DepthScaling
      //
      typedef ::malmo::schemas::DepthScaling DepthScaling_type;
      typedef ::xsd::cxx::tree::optional< DepthScaling_type > DepthScaling_optional;
      typedef ::xsd::cxx::tree::traits< DepthScaling_type, char > DepthScaling_traits;

      const DepthScaling_optional&
      DepthScaling () const;

      DepthScaling_optional&
      DepthScaling ();

      void
      DepthScaling (const DepthScaling_type& x);

      void
      DepthScaling (const DepthScaling_optional& x);

      void
      DepthScaling (::std::auto_ptr< DepthScaling_type > p);

      // want_depth
      //
      typedef ::xml_schema::boolean want_depth_type;
      typedef ::xsd::cxx::tree::traits< want_depth_type, char > want_depth_traits;

      const want_depth_type&
      want_depth () const;

      want_depth_type&
      want_depth ();

      void
      want_depth (const want_depth_type& x);

      static want_depth_type
      want_depth_default_value ();

      // viewpoint
      //
      typedef ::malmo::schemas::viewpoint viewpoint_type;
      typedef ::xsd::cxx::tree::traits< viewpoint_type, char > viewpoint_traits;

      const viewpoint_type&
      viewpoint () const;

      viewpoint_type&
      viewpoint ();

      void
      viewpoint (const viewpoint_type& x);

      void
      viewpoint (::std::auto_ptr< viewpoint_type > p);

      static viewpoint_type
      viewpoint_default_value ();

      // Constructors.
      //
      VideoProducer (const Width_type&,
                     const Height_type&);

      VideoProducer (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      VideoProducer (const VideoProducer& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual VideoProducer*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      VideoProducer&
      operator= (const VideoProducer& x);

      virtual 
      ~VideoProducer ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< Width_type > Width_;
      ::xsd::cxx::tree::one< Height_type > Height_;
      DepthScaling_optional DepthScaling_;
      ::xsd::cxx::tree::one< want_depth_type > want_depth_;
      ::xsd::cxx::tree::one< viewpoint_type > viewpoint_;
    };

    class type: public ::xml_schema::string
    {
      public:
      enum value
      {
        deny_list,
        allow_list
      };

      type (value v);

      type (const char* v);

      type (const ::std::string& v);

      type (const ::xml_schema::string& v);

      type (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      type (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      type (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      type (const type& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual type*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      type&
      operator= (value v);

      virtual
      operator value () const
      {
        return _xsd_type_convert ();
      }

      protected:
      value
      _xsd_type_convert () const;

      public:
      static const char* const _xsd_type_literals_[2];
      static const value _xsd_type_indexes_[2];
    };

    class ContinuousMovementCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // turnSpeedDegs
      //
      typedef ::xml_schema::decimal turnSpeedDegs_type;
      typedef ::xsd::cxx::tree::traits< turnSpeedDegs_type, char, ::xsd::cxx::tree::schema_type::decimal > turnSpeedDegs_traits;

      const turnSpeedDegs_type&
      turnSpeedDegs () const;

      turnSpeedDegs_type&
      turnSpeedDegs ();

      void
      turnSpeedDegs (const turnSpeedDegs_type& x);

      static turnSpeedDegs_type
      turnSpeedDegs_default_value ();

      // Constructors.
      //
      ContinuousMovementCommands ();

      ContinuousMovementCommands (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      ContinuousMovementCommands (const ContinuousMovementCommands& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual ContinuousMovementCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ContinuousMovementCommands&
      operator= (const ContinuousMovementCommands& x);

      virtual 
      ~ContinuousMovementCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
      ::xsd::cxx::tree::one< turnSpeedDegs_type > turnSpeedDegs_;
    };

    class AbsoluteMovementCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // Constructors.
      //
      AbsoluteMovementCommands ();

      AbsoluteMovementCommands (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      AbsoluteMovementCommands (const AbsoluteMovementCommands& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual AbsoluteMovementCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AbsoluteMovementCommands&
      operator= (const AbsoluteMovementCommands& x);

      virtual 
      ~AbsoluteMovementCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
    };

    class DiscreteMovementCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // autoFall
      //
      typedef ::xml_schema::boolean autoFall_type;
      typedef ::xsd::cxx::tree::traits< autoFall_type, char > autoFall_traits;

      const autoFall_type&
      autoFall () const;

      autoFall_type&
      autoFall ();

      void
      autoFall (const autoFall_type& x);

      static autoFall_type
      autoFall_default_value ();

      // autoJump
      //
      typedef ::xml_schema::boolean autoJump_type;
      typedef ::xsd::cxx::tree::traits< autoJump_type, char > autoJump_traits;

      const autoJump_type&
      autoJump () const;

      autoJump_type&
      autoJump ();

      void
      autoJump (const autoJump_type& x);

      static autoJump_type
      autoJump_default_value ();

      // Constructors.
      //
      DiscreteMovementCommands ();

      DiscreteMovementCommands (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      DiscreteMovementCommands (const DiscreteMovementCommands& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual DiscreteMovementCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DiscreteMovementCommands&
      operator= (const DiscreteMovementCommands& x);

      virtual 
      ~DiscreteMovementCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
      ::xsd::cxx::tree::one< autoFall_type > autoFall_;
      ::xsd::cxx::tree::one< autoJump_type > autoJump_;
    };

    class InventoryCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // Constructors.
      //
      InventoryCommands ();

      InventoryCommands (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      InventoryCommands (const InventoryCommands& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual InventoryCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      InventoryCommands&
      operator= (const InventoryCommands& x);

      virtual 
      ~InventoryCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
    };

    class SimpleCraftCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // Constructors.
      //
      SimpleCraftCommands ();

      SimpleCraftCommands (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      SimpleCraftCommands (const SimpleCraftCommands& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual SimpleCraftCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SimpleCraftCommands&
      operator= (const SimpleCraftCommands& x);

      virtual 
      ~SimpleCraftCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
    };

    class ChatCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // Constructors.
      //
      ChatCommands ();

      ChatCommands (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ChatCommands (const ChatCommands& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ChatCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ChatCommands&
      operator= (const ChatCommands& x);

      virtual 
      ~ChatCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
    };

    class MissionQuitCommands: public ::xml_schema::type
    {
      public:
      // ModifierList
      //
      typedef ::malmo::schemas::ModifierList ModifierList_type;
      typedef ::xsd::cxx::tree::optional< ModifierList_type > ModifierList_optional;
      typedef ::xsd::cxx::tree::traits< ModifierList_type, char > ModifierList_traits;

      const ModifierList_optional&
      ModifierList () const;

      ModifierList_optional&
      ModifierList ();

      void
      ModifierList (const ModifierList_type& x);

      void
      ModifierList (const ModifierList_optional& x);

      void
      ModifierList (::std::auto_ptr< ModifierList_type > p);

      // quitDescription
      //
      typedef ::xml_schema::string quitDescription_type;
      typedef ::xsd::cxx::tree::traits< quitDescription_type, char > quitDescription_traits;

      const quitDescription_type&
      quitDescription () const;

      quitDescription_type&
      quitDescription ();

      void
      quitDescription (const quitDescription_type& x);

      void
      quitDescription (::std::auto_ptr< quitDescription_type > p);

      static const quitDescription_type&
      quitDescription_default_value ();

      // Constructors.
      //
      MissionQuitCommands ();

      MissionQuitCommands (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      MissionQuitCommands (const MissionQuitCommands& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual MissionQuitCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      MissionQuitCommands&
      operator= (const MissionQuitCommands& x);

      virtual 
      ~MissionQuitCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ModifierList_optional ModifierList_;
      ::xsd::cxx::tree::one< quitDescription_type > quitDescription_;
      static const quitDescription_type quitDescription_default_value_;
    };

    class TurnBasedCommands: public ::xml_schema::type
    {
      public:
      // AbsoluteMovementCommands
      //
      typedef ::malmo::schemas::AbsoluteMovementCommands AbsoluteMovementCommands_type;
      typedef ::xsd::cxx::tree::optional< AbsoluteMovementCommands_type > AbsoluteMovementCommands_optional;
      typedef ::xsd::cxx::tree::traits< AbsoluteMovementCommands_type, char > AbsoluteMovementCommands_traits;

      const AbsoluteMovementCommands_optional&
      AbsoluteMovementCommands () const;

      AbsoluteMovementCommands_optional&
      AbsoluteMovementCommands ();

      void
      AbsoluteMovementCommands (const AbsoluteMovementCommands_type& x);

      void
      AbsoluteMovementCommands (const AbsoluteMovementCommands_optional& x);

      void
      AbsoluteMovementCommands (::std::auto_ptr< AbsoluteMovementCommands_type > p);

      // DiscreteMovementCommands
      //
      typedef ::malmo::schemas::DiscreteMovementCommands DiscreteMovementCommands_type;
      typedef ::xsd::cxx::tree::optional< DiscreteMovementCommands_type > DiscreteMovementCommands_optional;
      typedef ::xsd::cxx::tree::traits< DiscreteMovementCommands_type, char > DiscreteMovementCommands_traits;

      const DiscreteMovementCommands_optional&
      DiscreteMovementCommands () const;

      DiscreteMovementCommands_optional&
      DiscreteMovementCommands ();

      void
      DiscreteMovementCommands (const DiscreteMovementCommands_type& x);

      void
      DiscreteMovementCommands (const DiscreteMovementCommands_optional& x);

      void
      DiscreteMovementCommands (::std::auto_ptr< DiscreteMovementCommands_type > p);

      // InventoryCommands
      //
      typedef ::malmo::schemas::InventoryCommands InventoryCommands_type;
      typedef ::xsd::cxx::tree::optional< InventoryCommands_type > InventoryCommands_optional;
      typedef ::xsd::cxx::tree::traits< InventoryCommands_type, char > InventoryCommands_traits;

      const InventoryCommands_optional&
      InventoryCommands () const;

      InventoryCommands_optional&
      InventoryCommands ();

      void
      InventoryCommands (const InventoryCommands_type& x);

      void
      InventoryCommands (const InventoryCommands_optional& x);

      void
      InventoryCommands (::std::auto_ptr< InventoryCommands_type > p);

      // ChatCommands
      //
      typedef ::malmo::schemas::ChatCommands ChatCommands_type;
      typedef ::xsd::cxx::tree::optional< ChatCommands_type > ChatCommands_optional;
      typedef ::xsd::cxx::tree::traits< ChatCommands_type, char > ChatCommands_traits;

      const ChatCommands_optional&
      ChatCommands () const;

      ChatCommands_optional&
      ChatCommands ();

      void
      ChatCommands (const ChatCommands_type& x);

      void
      ChatCommands (const ChatCommands_optional& x);

      void
      ChatCommands (::std::auto_ptr< ChatCommands_type > p);

      // SimpleCraftCommands
      //
      typedef ::malmo::schemas::SimpleCraftCommands SimpleCraftCommands_type;
      typedef ::xsd::cxx::tree::optional< SimpleCraftCommands_type > SimpleCraftCommands_optional;
      typedef ::xsd::cxx::tree::traits< SimpleCraftCommands_type, char > SimpleCraftCommands_traits;

      const SimpleCraftCommands_optional&
      SimpleCraftCommands () const;

      SimpleCraftCommands_optional&
      SimpleCraftCommands ();

      void
      SimpleCraftCommands (const SimpleCraftCommands_type& x);

      void
      SimpleCraftCommands (const SimpleCraftCommands_optional& x);

      void
      SimpleCraftCommands (::std::auto_ptr< SimpleCraftCommands_type > p);

      // MissionQuitCommands
      //
      typedef ::malmo::schemas::MissionQuitCommands MissionQuitCommands_type;
      typedef ::xsd::cxx::tree::optional< MissionQuitCommands_type > MissionQuitCommands_optional;
      typedef ::xsd::cxx::tree::traits< MissionQuitCommands_type, char > MissionQuitCommands_traits;

      const MissionQuitCommands_optional&
      MissionQuitCommands () const;

      MissionQuitCommands_optional&
      MissionQuitCommands ();

      void
      MissionQuitCommands (const MissionQuitCommands_type& x);

      void
      MissionQuitCommands (const MissionQuitCommands_optional& x);

      void
      MissionQuitCommands (::std::auto_ptr< MissionQuitCommands_type > p);

      // requestedPosition
      //
      typedef ::malmo::schemas::requestedPosition requestedPosition_type;
      typedef ::xsd::cxx::tree::optional< requestedPosition_type > requestedPosition_optional;
      typedef ::xsd::cxx::tree::traits< requestedPosition_type, char > requestedPosition_traits;

      const requestedPosition_optional&
      requestedPosition () const;

      requestedPosition_optional&
      requestedPosition ();

      void
      requestedPosition (const requestedPosition_type& x);

      void
      requestedPosition (const requestedPosition_optional& x);

      void
      requestedPosition (::std::auto_ptr< requestedPosition_type > p);

      // Constructors.
      //
      TurnBasedCommands ();

      TurnBasedCommands (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      TurnBasedCommands (const TurnBasedCommands& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual TurnBasedCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TurnBasedCommands&
      operator= (const TurnBasedCommands& x);

      virtual 
      ~TurnBasedCommands ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      AbsoluteMovementCommands_optional AbsoluteMovementCommands_;
      DiscreteMovementCommands_optional DiscreteMovementCommands_;
      InventoryCommands_optional InventoryCommands_;
      ChatCommands_optional ChatCommands_;
      SimpleCraftCommands_optional SimpleCraftCommands_;
      MissionQuitCommands_optional MissionQuitCommands_;
      requestedPosition_optional requestedPosition_;
    };

    class ObservationFromRecentCommands: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromRecentCommands ();

      ObservationFromRecentCommands (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ObservationFromRecentCommands (const ::xercesc::DOMAttr& a,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ObservationFromRecentCommands (const ::std::string& s,
                                     const ::xercesc::DOMElement* e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ObservationFromRecentCommands (const ObservationFromRecentCommands& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ObservationFromRecentCommands*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromRecentCommands ();
    };

    class ObservationFromTurnScheduler: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromTurnScheduler ();

      ObservationFromTurnScheduler (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ObservationFromTurnScheduler (const ::xercesc::DOMAttr& a,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ObservationFromTurnScheduler (const ::std::string& s,
                                    const ::xercesc::DOMElement* e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ObservationFromTurnScheduler (const ObservationFromTurnScheduler& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ObservationFromTurnScheduler*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromTurnScheduler ();
    };

    class ObservationFromSubgoalPositionList: public ::xml_schema::type
    {
      public:
      // Point
      //
      typedef ::malmo::schemas::PointWithToleranceAndDescription Point_type;
      typedef ::xsd::cxx::tree::sequence< Point_type > Point_sequence;
      typedef Point_sequence::iterator Point_iterator;
      typedef Point_sequence::const_iterator Point_const_iterator;
      typedef ::xsd::cxx::tree::traits< Point_type, char > Point_traits;

      const Point_sequence&
      Point () const;

      Point_sequence&
      Point ();

      void
      Point (const Point_sequence& s);

      // Constructors.
      //
      ObservationFromSubgoalPositionList ();

      ObservationFromSubgoalPositionList (const ::xercesc::DOMElement& e,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      ObservationFromSubgoalPositionList (const ObservationFromSubgoalPositionList& x,
                                          ::xml_schema::flags f = 0,
                                          ::xml_schema::container* c = 0);

      virtual ObservationFromSubgoalPositionList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ObservationFromSubgoalPositionList&
      operator= (const ObservationFromSubgoalPositionList& x);

      virtual 
      ~ObservationFromSubgoalPositionList ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Point_sequence Point_;
    };

    class ObservationFromHotBar: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromHotBar ();

      ObservationFromHotBar (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ObservationFromHotBar (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ObservationFromHotBar (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      ObservationFromHotBar (const ObservationFromHotBar& x,
                             ::xml_schema::flags f = 0,
                             ::xml_schema::container* c = 0);

      virtual ObservationFromHotBar*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromHotBar ();
    };

    class ObservationFromFullStats: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromFullStats ();

      ObservationFromFullStats (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ObservationFromFullStats (const ::xercesc::DOMAttr& a,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ObservationFromFullStats (const ::std::string& s,
                                const ::xercesc::DOMElement* e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      ObservationFromFullStats (const ObservationFromFullStats& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual ObservationFromFullStats*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromFullStats ();
    };

    class ObservationFromRay: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromRay ();

      ObservationFromRay (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ObservationFromRay (const ::xercesc::DOMAttr& a,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ObservationFromRay (const ::std::string& s,
                          const ::xercesc::DOMElement* e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      ObservationFromRay (const ObservationFromRay& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual ObservationFromRay*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromRay ();
    };

    class ObservationFromFullInventory: public ::xml_schema::type
    {
      public:
      // flat
      //
      typedef ::xml_schema::boolean flat_type;
      typedef ::xsd::cxx::tree::traits< flat_type, char > flat_traits;

      const flat_type&
      flat () const;

      flat_type&
      flat ();

      void
      flat (const flat_type& x);

      static flat_type
      flat_default_value ();

      // Constructors.
      //
      ObservationFromFullInventory ();

      ObservationFromFullInventory (const ::xercesc::DOMElement& e,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      ObservationFromFullInventory (const ObservationFromFullInventory& x,
                                    ::xml_schema::flags f = 0,
                                    ::xml_schema::container* c = 0);

      virtual ObservationFromFullInventory*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ObservationFromFullInventory&
      operator= (const ObservationFromFullInventory& x);

      virtual 
      ~ObservationFromFullInventory ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< flat_type > flat_;
    };

    class ObservationFromDiscreteCell: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromDiscreteCell ();

      ObservationFromDiscreteCell (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ObservationFromDiscreteCell (const ::xercesc::DOMAttr& a,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ObservationFromDiscreteCell (const ::std::string& s,
                                   const ::xercesc::DOMElement* e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      ObservationFromDiscreteCell (const ObservationFromDiscreteCell& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual ObservationFromDiscreteCell*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromDiscreteCell ();
    };

    class ObservationFromDistance: public ::xml_schema::type
    {
      public:
      // Marker
      //
      typedef ::malmo::schemas::NamedPoint Marker_type;
      typedef ::xsd::cxx::tree::sequence< Marker_type > Marker_sequence;
      typedef Marker_sequence::iterator Marker_iterator;
      typedef Marker_sequence::const_iterator Marker_const_iterator;
      typedef ::xsd::cxx::tree::traits< Marker_type, char > Marker_traits;

      const Marker_sequence&
      Marker () const;

      Marker_sequence&
      Marker ();

      void
      Marker (const Marker_sequence& s);

      // Constructors.
      //
      ObservationFromDistance ();

      ObservationFromDistance (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      ObservationFromDistance (const ObservationFromDistance& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual ObservationFromDistance*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ObservationFromDistance&
      operator= (const ObservationFromDistance& x);

      virtual 
      ~ObservationFromDistance ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Marker_sequence Marker_;
    };

    class ObservationFromGrid: public ::xml_schema::type
    {
      public:
      // Grid
      //
      typedef ::malmo::schemas::GridDefinition Grid_type;
      typedef ::xsd::cxx::tree::sequence< Grid_type > Grid_sequence;
      typedef Grid_sequence::iterator Grid_iterator;
      typedef Grid_sequence::const_iterator Grid_const_iterator;
      typedef ::xsd::cxx::tree::traits< Grid_type, char > Grid_traits;

      const Grid_sequence&
      Grid () const;

      Grid_sequence&
      Grid ();

      void
      Grid (const Grid_sequence& s);

      // Constructors.
      //
      ObservationFromGrid ();

      ObservationFromGrid (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ObservationFromGrid (const ObservationFromGrid& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ObservationFromGrid*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ObservationFromGrid&
      operator= (const ObservationFromGrid& x);

      virtual 
      ~ObservationFromGrid ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Grid_sequence Grid_;
    };

    class ObservationFromNearbyEntities: public ::xml_schema::type
    {
      public:
      // Range
      //
      typedef ::malmo::schemas::RangeDefinition Range_type;
      typedef ::xsd::cxx::tree::sequence< Range_type > Range_sequence;
      typedef Range_sequence::iterator Range_iterator;
      typedef Range_sequence::const_iterator Range_const_iterator;
      typedef ::xsd::cxx::tree::traits< Range_type, char > Range_traits;

      const Range_sequence&
      Range () const;

      Range_sequence&
      Range ();

      void
      Range (const Range_sequence& s);

      // Constructors.
      //
      ObservationFromNearbyEntities ();

      ObservationFromNearbyEntities (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      ObservationFromNearbyEntities (const ObservationFromNearbyEntities& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual ObservationFromNearbyEntities*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      ObservationFromNearbyEntities&
      operator= (const ObservationFromNearbyEntities& x);

      virtual 
      ~ObservationFromNearbyEntities ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Range_sequence Range_;
    };

    class ObservationFromChat: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      ObservationFromChat ();

      ObservationFromChat (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ObservationFromChat (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ObservationFromChat (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      ObservationFromChat (const ObservationFromChat& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual ObservationFromChat*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ObservationFromChat ();
    };

    class RewardForDamagingEntity: public ::xml_schema::type
    {
      public:
      // Mob
      //
      typedef ::malmo::schemas::MobWithReward Mob_type;
      typedef ::xsd::cxx::tree::sequence< Mob_type > Mob_sequence;
      typedef Mob_sequence::iterator Mob_iterator;
      typedef Mob_sequence::const_iterator Mob_const_iterator;
      typedef ::xsd::cxx::tree::traits< Mob_type, char > Mob_traits;

      const Mob_sequence&
      Mob () const;

      Mob_sequence&
      Mob ();

      void
      Mob (const Mob_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForDamagingEntity ();

      RewardForDamagingEntity (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RewardForDamagingEntity (const RewardForDamagingEntity& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual RewardForDamagingEntity*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForDamagingEntity&
      operator= (const RewardForDamagingEntity& x);

      virtual 
      ~RewardForDamagingEntity ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Mob_sequence Mob_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForReachingPosition: public ::xml_schema::type
    {
      public:
      // Marker
      //
      typedef ::malmo::schemas::PointWithReward Marker_type;
      typedef ::xsd::cxx::tree::sequence< Marker_type > Marker_sequence;
      typedef Marker_sequence::iterator Marker_iterator;
      typedef Marker_sequence::const_iterator Marker_const_iterator;
      typedef ::xsd::cxx::tree::traits< Marker_type, char > Marker_traits;

      const Marker_sequence&
      Marker () const;

      Marker_sequence&
      Marker ();

      void
      Marker (const Marker_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForReachingPosition ();

      RewardForReachingPosition (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      RewardForReachingPosition (const RewardForReachingPosition& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual RewardForReachingPosition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForReachingPosition&
      operator= (const RewardForReachingPosition& x);

      virtual 
      ~RewardForReachingPosition ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Marker_sequence Marker_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForTouchingBlockType: public ::xml_schema::type
    {
      public:
      // Block
      //
      typedef ::malmo::schemas::BlockSpecWithRewardAndBehaviour Block_type;
      typedef ::xsd::cxx::tree::sequence< Block_type > Block_sequence;
      typedef Block_sequence::iterator Block_iterator;
      typedef Block_sequence::const_iterator Block_const_iterator;
      typedef ::xsd::cxx::tree::traits< Block_type, char > Block_traits;

      const Block_sequence&
      Block () const;

      Block_sequence&
      Block ();

      void
      Block (const Block_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForTouchingBlockType ();

      RewardForTouchingBlockType (const ::xercesc::DOMElement& e,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      RewardForTouchingBlockType (const RewardForTouchingBlockType& x,
                                  ::xml_schema::flags f = 0,
                                  ::xml_schema::container* c = 0);

      virtual RewardForTouchingBlockType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForTouchingBlockType&
      operator= (const RewardForTouchingBlockType& x);

      virtual 
      ~RewardForTouchingBlockType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Block_sequence Block_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForSendingCommand: public ::xml_schema::type
    {
      public:
      // reward
      //
      typedef ::xml_schema::decimal reward_type;
      typedef ::xsd::cxx::tree::traits< reward_type, char, ::xsd::cxx::tree::schema_type::decimal > reward_traits;

      const reward_type&
      reward () const;

      reward_type&
      reward ();

      void
      reward (const reward_type& x);

      static reward_type
      reward_default_value ();

      // distribution
      //
      typedef ::xml_schema::string distribution_type;
      typedef ::xsd::cxx::tree::traits< distribution_type, char > distribution_traits;

      const distribution_type&
      distribution () const;

      distribution_type&
      distribution ();

      void
      distribution (const distribution_type& x);

      void
      distribution (::std::auto_ptr< distribution_type > p);

      static const distribution_type&
      distribution_default_value ();

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForSendingCommand ();

      RewardForSendingCommand (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RewardForSendingCommand (const RewardForSendingCommand& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual RewardForSendingCommand*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForSendingCommand&
      operator= (const RewardForSendingCommand& x);

      virtual 
      ~RewardForSendingCommand ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< reward_type > reward_;
      ::xsd::cxx::tree::one< distribution_type > distribution_;
      static const distribution_type distribution_default_value_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForSendingMatchingChatMessage: public ::xml_schema::type
    {
      public:
      // ChatMatch
      //
      typedef ::malmo::schemas::ChatMatchSpec ChatMatch_type;
      typedef ::xsd::cxx::tree::sequence< ChatMatch_type > ChatMatch_sequence;
      typedef ChatMatch_sequence::iterator ChatMatch_iterator;
      typedef ChatMatch_sequence::const_iterator ChatMatch_const_iterator;
      typedef ::xsd::cxx::tree::traits< ChatMatch_type, char > ChatMatch_traits;

      const ChatMatch_sequence&
      ChatMatch () const;

      ChatMatch_sequence&
      ChatMatch ();

      void
      ChatMatch (const ChatMatch_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForSendingMatchingChatMessage ();

      RewardForSendingMatchingChatMessage (const ::xercesc::DOMElement& e,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      RewardForSendingMatchingChatMessage (const RewardForSendingMatchingChatMessage& x,
                                           ::xml_schema::flags f = 0,
                                           ::xml_schema::container* c = 0);

      virtual RewardForSendingMatchingChatMessage*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForSendingMatchingChatMessage&
      operator= (const RewardForSendingMatchingChatMessage& x);

      virtual 
      ~RewardForSendingMatchingChatMessage ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ChatMatch_sequence ChatMatch_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForCollectingItem: public ::xml_schema::type
    {
      public:
      // Item
      //
      typedef ::malmo::schemas::BlockOrItemSpecWithReward Item_type;
      typedef ::xsd::cxx::tree::sequence< Item_type > Item_sequence;
      typedef Item_sequence::iterator Item_iterator;
      typedef Item_sequence::const_iterator Item_const_iterator;
      typedef ::xsd::cxx::tree::traits< Item_type, char > Item_traits;

      const Item_sequence&
      Item () const;

      Item_sequence&
      Item ();

      void
      Item (const Item_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForCollectingItem ();

      RewardForCollectingItem (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RewardForCollectingItem (const RewardForCollectingItem& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual RewardForCollectingItem*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForCollectingItem&
      operator= (const RewardForCollectingItem& x);

      virtual 
      ~RewardForCollectingItem ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Item_sequence Item_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForDiscardingItem: public ::xml_schema::type
    {
      public:
      // Item
      //
      typedef ::malmo::schemas::BlockOrItemSpecWithReward Item_type;
      typedef ::xsd::cxx::tree::sequence< Item_type > Item_sequence;
      typedef Item_sequence::iterator Item_iterator;
      typedef Item_sequence::const_iterator Item_const_iterator;
      typedef ::xsd::cxx::tree::traits< Item_type, char > Item_traits;

      const Item_sequence&
      Item () const;

      Item_sequence&
      Item ();

      void
      Item (const Item_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForDiscardingItem ();

      RewardForDiscardingItem (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      RewardForDiscardingItem (const RewardForDiscardingItem& x,
                               ::xml_schema::flags f = 0,
                               ::xml_schema::container* c = 0);

      virtual RewardForDiscardingItem*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForDiscardingItem&
      operator= (const RewardForDiscardingItem& x);

      virtual 
      ~RewardForDiscardingItem ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Item_sequence Item_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class RewardForMissionEnd: public ::xml_schema::type
    {
      public:
      // Reward
      //
      typedef ::malmo::schemas::MissionEndRewardCase Reward_type;
      typedef ::xsd::cxx::tree::sequence< Reward_type > Reward_sequence;
      typedef Reward_sequence::iterator Reward_iterator;
      typedef Reward_sequence::const_iterator Reward_const_iterator;
      typedef ::xsd::cxx::tree::traits< Reward_type, char > Reward_traits;

      const Reward_sequence&
      Reward () const;

      Reward_sequence&
      Reward ();

      void
      Reward (const Reward_sequence& s);

      // rewardForDeath
      //
      typedef ::xml_schema::decimal rewardForDeath_type;
      typedef ::xsd::cxx::tree::traits< rewardForDeath_type, char, ::xsd::cxx::tree::schema_type::decimal > rewardForDeath_traits;

      const rewardForDeath_type&
      rewardForDeath () const;

      rewardForDeath_type&
      rewardForDeath ();

      void
      rewardForDeath (const rewardForDeath_type& x);

      static rewardForDeath_type
      rewardForDeath_default_value ();

      // rewardForDeathDistribution
      //
      typedef ::xml_schema::string rewardForDeathDistribution_type;
      typedef ::xsd::cxx::tree::traits< rewardForDeathDistribution_type, char > rewardForDeathDistribution_traits;

      const rewardForDeathDistribution_type&
      rewardForDeathDistribution () const;

      rewardForDeathDistribution_type&
      rewardForDeathDistribution ();

      void
      rewardForDeathDistribution (const rewardForDeathDistribution_type& x);

      void
      rewardForDeathDistribution (::std::auto_ptr< rewardForDeathDistribution_type > p);

      static const rewardForDeathDistribution_type&
      rewardForDeathDistribution_default_value ();

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForMissionEnd ();

      RewardForMissionEnd (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      RewardForMissionEnd (const RewardForMissionEnd& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual RewardForMissionEnd*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForMissionEnd&
      operator= (const RewardForMissionEnd& x);

      virtual 
      ~RewardForMissionEnd ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Reward_sequence Reward_;
      ::xsd::cxx::tree::one< rewardForDeath_type > rewardForDeath_;
      ::xsd::cxx::tree::one< rewardForDeathDistribution_type > rewardForDeathDistribution_;
      static const rewardForDeathDistribution_type rewardForDeathDistribution_default_value_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class min: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::int_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::int_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::int_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // Constructors.
      //
      min (const x_type&,
           const y_type&,
           const z_type&);

      min (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      min (const min& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      virtual min*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      min&
      operator= (const min& x);

      virtual 
      ~min ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
    };

    class max: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::int_ x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      // y
      //
      typedef ::xml_schema::int_ y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      // z
      //
      typedef ::xml_schema::int_ z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      // Constructors.
      //
      max (const x_type&,
           const y_type&,
           const z_type&);

      max (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      max (const max& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

      virtual max*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      max&
      operator= (const max& x);

      virtual 
      ~max ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
    };

    class RewardForStructureCopying: public ::xml_schema::type
    {
      public:
      // RewardDensity
      //
      typedef ::malmo::schemas::RewardDensityForBuildAndBreak RewardDensity_type;
      typedef ::xsd::cxx::tree::traits< RewardDensity_type, char > RewardDensity_traits;

      const RewardDensity_type&
      RewardDensity () const;

      RewardDensity_type&
      RewardDensity ();

      void
      RewardDensity (const RewardDensity_type& x);

      void
      RewardDensity (::std::auto_ptr< RewardDensity_type > p);

      // AddQuitProducer
      //
      typedef ::malmo::schemas::AddQuitProducer AddQuitProducer_type;
      typedef ::xsd::cxx::tree::optional< AddQuitProducer_type > AddQuitProducer_optional;
      typedef ::xsd::cxx::tree::traits< AddQuitProducer_type, char > AddQuitProducer_traits;

      const AddQuitProducer_optional&
      AddQuitProducer () const;

      AddQuitProducer_optional&
      AddQuitProducer ();

      void
      AddQuitProducer (const AddQuitProducer_type& x);

      void
      AddQuitProducer (const AddQuitProducer_optional& x);

      void
      AddQuitProducer (::std::auto_ptr< AddQuitProducer_type > p);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // rewardScale
      //
      typedef ::xml_schema::decimal rewardScale_type;
      typedef ::xsd::cxx::tree::traits< rewardScale_type, char, ::xsd::cxx::tree::schema_type::decimal > rewardScale_traits;

      const rewardScale_type&
      rewardScale () const;

      rewardScale_type&
      rewardScale ();

      void
      rewardScale (const rewardScale_type& x);

      static rewardScale_type
      rewardScale_default_value ();

      // rewardDistribution
      //
      typedef ::xml_schema::string rewardDistribution_type;
      typedef ::xsd::cxx::tree::traits< rewardDistribution_type, char > rewardDistribution_traits;

      const rewardDistribution_type&
      rewardDistribution () const;

      rewardDistribution_type&
      rewardDistribution ();

      void
      rewardDistribution (const rewardDistribution_type& x);

      void
      rewardDistribution (::std::auto_ptr< rewardDistribution_type > p);

      static const rewardDistribution_type&
      rewardDistribution_default_value ();

      // rewardForCompletion
      //
      typedef ::xml_schema::decimal rewardForCompletion_type;
      typedef ::xsd::cxx::tree::traits< rewardForCompletion_type, char, ::xsd::cxx::tree::schema_type::decimal > rewardForCompletion_traits;

      const rewardForCompletion_type&
      rewardForCompletion () const;

      rewardForCompletion_type&
      rewardForCompletion ();

      void
      rewardForCompletion (const rewardForCompletion_type& x);

      static rewardForCompletion_type
      rewardForCompletion_default_value ();

      // Constructors.
      //
      RewardForStructureCopying (const RewardDensity_type&);

      RewardForStructureCopying (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      RewardForStructureCopying (const RewardForStructureCopying& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual RewardForStructureCopying*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForStructureCopying&
      operator= (const RewardForStructureCopying& x);

      virtual 
      ~RewardForStructureCopying ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< RewardDensity_type > RewardDensity_;
      AddQuitProducer_optional AddQuitProducer_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
      ::xsd::cxx::tree::one< rewardScale_type > rewardScale_;
      ::xsd::cxx::tree::one< rewardDistribution_type > rewardDistribution_;
      static const rewardDistribution_type rewardDistribution_default_value_;
      ::xsd::cxx::tree::one< rewardForCompletion_type > rewardForCompletion_;
    };

    class RewardForTimeTaken: public ::xml_schema::type
    {
      public:
      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // initialReward
      //
      typedef ::xml_schema::decimal initialReward_type;
      typedef ::xsd::cxx::tree::traits< initialReward_type, char, ::xsd::cxx::tree::schema_type::decimal > initialReward_traits;

      const initialReward_type&
      initialReward () const;

      initialReward_type&
      initialReward ();

      void
      initialReward (const initialReward_type& x);

      // delta
      //
      typedef ::xml_schema::decimal delta_type;
      typedef ::xsd::cxx::tree::traits< delta_type, char, ::xsd::cxx::tree::schema_type::decimal > delta_traits;

      const delta_type&
      delta () const;

      delta_type&
      delta ();

      void
      delta (const delta_type& x);

      // density
      //
      typedef ::malmo::schemas::RewardDensityForTimeTaken density_type;
      typedef ::xsd::cxx::tree::traits< density_type, char > density_traits;

      const density_type&
      density () const;

      density_type&
      density ();

      void
      density (const density_type& x);

      void
      density (::std::auto_ptr< density_type > p);

      // rewardDistribution
      //
      typedef ::xml_schema::string rewardDistribution_type;
      typedef ::xsd::cxx::tree::traits< rewardDistribution_type, char > rewardDistribution_traits;

      const rewardDistribution_type&
      rewardDistribution () const;

      rewardDistribution_type&
      rewardDistribution ();

      void
      rewardDistribution (const rewardDistribution_type& x);

      void
      rewardDistribution (::std::auto_ptr< rewardDistribution_type > p);

      static const rewardDistribution_type&
      rewardDistribution_default_value ();

      // Constructors.
      //
      RewardForTimeTaken (const initialReward_type&,
                          const delta_type&,
                          const density_type&);

      RewardForTimeTaken (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      RewardForTimeTaken (const RewardForTimeTaken& x,
                          ::xml_schema::flags f = 0,
                          ::xml_schema::container* c = 0);

      virtual RewardForTimeTaken*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForTimeTaken&
      operator= (const RewardForTimeTaken& x);

      virtual 
      ~RewardForTimeTaken ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< dimension_type > dimension_;
      ::xsd::cxx::tree::one< initialReward_type > initialReward_;
      ::xsd::cxx::tree::one< delta_type > delta_;
      ::xsd::cxx::tree::one< density_type > density_;
      ::xsd::cxx::tree::one< rewardDistribution_type > rewardDistribution_;
      static const rewardDistribution_type rewardDistribution_default_value_;
    };

    class RewardForCatchingMob: public ::xml_schema::type
    {
      public:
      // Mob
      //
      typedef ::malmo::schemas::MobWithDescriptionAndReward Mob_type;
      typedef ::xsd::cxx::tree::sequence< Mob_type > Mob_sequence;
      typedef Mob_sequence::iterator Mob_iterator;
      typedef Mob_sequence::const_iterator Mob_const_iterator;
      typedef ::xsd::cxx::tree::traits< Mob_type, char > Mob_traits;

      const Mob_sequence&
      Mob () const;

      Mob_sequence&
      Mob ();

      void
      Mob (const Mob_sequence& s);

      // dimension
      //
      typedef ::malmo::schemas::Dimension dimension_type;
      typedef ::xsd::cxx::tree::traits< dimension_type, char > dimension_traits;

      const dimension_type&
      dimension () const;

      dimension_type&
      dimension ();

      void
      dimension (const dimension_type& x);

      void
      dimension (::std::auto_ptr< dimension_type > p);

      static dimension_type
      dimension_default_value ();

      // Constructors.
      //
      RewardForCatchingMob ();

      RewardForCatchingMob (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      RewardForCatchingMob (const RewardForCatchingMob& x,
                            ::xml_schema::flags f = 0,
                            ::xml_schema::container* c = 0);

      virtual RewardForCatchingMob*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      RewardForCatchingMob&
      operator= (const RewardForCatchingMob& x);

      virtual 
      ~RewardForCatchingMob ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Mob_sequence Mob_;
      ::xsd::cxx::tree::one< dimension_type > dimension_;
    };

    class AgentQuitFromReachingPosition: public ::xml_schema::type
    {
      public:
      // Marker
      //
      typedef ::malmo::schemas::PointWithToleranceAndDescription Marker_type;
      typedef ::xsd::cxx::tree::sequence< Marker_type > Marker_sequence;
      typedef Marker_sequence::iterator Marker_iterator;
      typedef Marker_sequence::const_iterator Marker_const_iterator;
      typedef ::xsd::cxx::tree::traits< Marker_type, char > Marker_traits;

      const Marker_sequence&
      Marker () const;

      Marker_sequence&
      Marker ();

      void
      Marker (const Marker_sequence& s);

      // Constructors.
      //
      AgentQuitFromReachingPosition ();

      AgentQuitFromReachingPosition (const ::xercesc::DOMElement& e,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      AgentQuitFromReachingPosition (const AgentQuitFromReachingPosition& x,
                                     ::xml_schema::flags f = 0,
                                     ::xml_schema::container* c = 0);

      virtual AgentQuitFromReachingPosition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentQuitFromReachingPosition&
      operator= (const AgentQuitFromReachingPosition& x);

      virtual 
      ~AgentQuitFromReachingPosition ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Marker_sequence Marker_;
    };

    class AgentQuitFromTimeUp: public ::xml_schema::type
    {
      public:
      // timeLimitMs
      //
      typedef ::xml_schema::decimal timeLimitMs_type;
      typedef ::xsd::cxx::tree::traits< timeLimitMs_type, char, ::xsd::cxx::tree::schema_type::decimal > timeLimitMs_traits;

      const timeLimitMs_type&
      timeLimitMs () const;

      timeLimitMs_type&
      timeLimitMs ();

      void
      timeLimitMs (const timeLimitMs_type& x);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      AgentQuitFromTimeUp (const timeLimitMs_type&);

      AgentQuitFromTimeUp (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      AgentQuitFromTimeUp (const AgentQuitFromTimeUp& x,
                           ::xml_schema::flags f = 0,
                           ::xml_schema::container* c = 0);

      virtual AgentQuitFromTimeUp*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentQuitFromTimeUp&
      operator= (const AgentQuitFromTimeUp& x);

      virtual 
      ~AgentQuitFromTimeUp ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< timeLimitMs_type > timeLimitMs_;
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class AgentQuitFromTouchingBlockType: public ::xml_schema::type
    {
      public:
      // Block
      //
      typedef ::malmo::schemas::BlockSpecWithDescription Block_type;
      typedef ::xsd::cxx::tree::sequence< Block_type > Block_sequence;
      typedef Block_sequence::iterator Block_iterator;
      typedef Block_sequence::const_iterator Block_const_iterator;
      typedef ::xsd::cxx::tree::traits< Block_type, char > Block_traits;

      const Block_sequence&
      Block () const;

      Block_sequence&
      Block ();

      void
      Block (const Block_sequence& s);

      // Constructors.
      //
      AgentQuitFromTouchingBlockType ();

      AgentQuitFromTouchingBlockType (const ::xercesc::DOMElement& e,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      AgentQuitFromTouchingBlockType (const AgentQuitFromTouchingBlockType& x,
                                      ::xml_schema::flags f = 0,
                                      ::xml_schema::container* c = 0);

      virtual AgentQuitFromTouchingBlockType*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentQuitFromTouchingBlockType&
      operator= (const AgentQuitFromTouchingBlockType& x);

      virtual 
      ~AgentQuitFromTouchingBlockType ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Block_sequence Block_;
    };

    class AgentQuitFromCollectingItem: public ::xml_schema::type
    {
      public:
      // Item
      //
      typedef ::malmo::schemas::BlockOrItemSpecWithDescription Item_type;
      typedef ::xsd::cxx::tree::sequence< Item_type > Item_sequence;
      typedef Item_sequence::iterator Item_iterator;
      typedef Item_sequence::const_iterator Item_const_iterator;
      typedef ::xsd::cxx::tree::traits< Item_type, char > Item_traits;

      const Item_sequence&
      Item () const;

      Item_sequence&
      Item ();

      void
      Item (const Item_sequence& s);

      // Constructors.
      //
      AgentQuitFromCollectingItem ();

      AgentQuitFromCollectingItem (const ::xercesc::DOMElement& e,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      AgentQuitFromCollectingItem (const AgentQuitFromCollectingItem& x,
                                   ::xml_schema::flags f = 0,
                                   ::xml_schema::container* c = 0);

      virtual AgentQuitFromCollectingItem*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentQuitFromCollectingItem&
      operator= (const AgentQuitFromCollectingItem& x);

      virtual 
      ~AgentQuitFromCollectingItem ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Item_sequence Item_;
    };

    class AgentQuitFromCatchingMob: public ::xml_schema::type
    {
      public:
      // Mob
      //
      typedef ::malmo::schemas::MobWithDescription Mob_type;
      typedef ::xsd::cxx::tree::sequence< Mob_type > Mob_sequence;
      typedef Mob_sequence::iterator Mob_iterator;
      typedef Mob_sequence::const_iterator Mob_const_iterator;
      typedef ::xsd::cxx::tree::traits< Mob_type, char > Mob_traits;

      const Mob_sequence&
      Mob () const;

      Mob_sequence&
      Mob ();

      void
      Mob (const Mob_sequence& s);

      // Constructors.
      //
      AgentQuitFromCatchingMob ();

      AgentQuitFromCatchingMob (const ::xercesc::DOMElement& e,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      AgentQuitFromCatchingMob (const AgentQuitFromCatchingMob& x,
                                ::xml_schema::flags f = 0,
                                ::xml_schema::container* c = 0);

      virtual AgentQuitFromCatchingMob*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentQuitFromCatchingMob&
      operator= (const AgentQuitFromCatchingMob& x);

      virtual 
      ~AgentQuitFromCatchingMob ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Mob_sequence Mob_;
    };

    class AgentQuitFromReachingCommandQuota: public ::xml_schema::type
    {
      public:
      // Quota
      //
      typedef ::malmo::schemas::CommandQuota Quota_type;
      typedef ::xsd::cxx::tree::sequence< Quota_type > Quota_sequence;
      typedef Quota_sequence::iterator Quota_iterator;
      typedef Quota_sequence::const_iterator Quota_const_iterator;
      typedef ::xsd::cxx::tree::traits< Quota_type, char > Quota_traits;

      const Quota_sequence&
      Quota () const;

      Quota_sequence&
      Quota ();

      void
      Quota (const Quota_sequence& s);

      // total
      //
      typedef ::xml_schema::int_ total_type;
      typedef ::xsd::cxx::tree::optional< total_type > total_optional;
      typedef ::xsd::cxx::tree::traits< total_type, char > total_traits;

      const total_optional&
      total () const;

      total_optional&
      total ();

      void
      total (const total_type& x);

      void
      total (const total_optional& x);

      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      AgentQuitFromReachingCommandQuota ();

      AgentQuitFromReachingCommandQuota (const ::xercesc::DOMElement& e,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      AgentQuitFromReachingCommandQuota (const AgentQuitFromReachingCommandQuota& x,
                                         ::xml_schema::flags f = 0,
                                         ::xml_schema::container* c = 0);

      virtual AgentQuitFromReachingCommandQuota*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AgentQuitFromReachingCommandQuota&
      operator= (const AgentQuitFromReachingCommandQuota& x);

      virtual 
      ~AgentQuitFromReachingCommandQuota ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      Quota_sequence Quota_;
      total_optional total_;
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class Seed: public ::xml_schema::string
    {
      public:
      // Constructors.
      //
      Seed ();

      Seed (const char*);

      Seed (const ::std::string&);

      Seed (const ::xml_schema::string&);

      Seed (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      Seed (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      Seed (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      Seed (const Seed& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual Seed*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~Seed ();
    };

    class UpdateSpeed: public ::xml_schema::string
    {
      public:
      // Constructors.
      //
      UpdateSpeed ();

      UpdateSpeed (const char*);

      UpdateSpeed (const ::std::string&);

      UpdateSpeed (const ::xml_schema::string&);

      UpdateSpeed (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      UpdateSpeed (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      UpdateSpeed (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      UpdateSpeed (const UpdateSpeed& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

      virtual UpdateSpeed*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~UpdateSpeed ();
    };

    class MaterialSeed: public ::xml_schema::string
    {
      public:
      // Constructors.
      //
      MaterialSeed ();

      MaterialSeed (const char*);

      MaterialSeed (const ::std::string&);

      MaterialSeed (const ::xml_schema::string&);

      MaterialSeed (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MaterialSeed (const ::xercesc::DOMAttr& a,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MaterialSeed (const ::std::string& s,
                    const ::xercesc::DOMElement* e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      MaterialSeed (const MaterialSeed& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual MaterialSeed*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~MaterialSeed ();
    };

    class GapProbability: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // variance
      //
      typedef ::xml_schema::decimal variance_type;
      typedef ::xsd::cxx::tree::traits< variance_type, char, ::xsd::cxx::tree::schema_type::decimal > variance_traits;

      const variance_type&
      variance () const;

      variance_type&
      variance ();

      void
      variance (const variance_type& x);

      static variance_type
      variance_default_value ();

      // Constructors.
      //
      GapProbability (const ::xml_schema::decimal&);

      GapProbability (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      GapProbability (const GapProbability& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

      virtual GapProbability*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      GapProbability&
      operator= (const GapProbability& x);

      virtual 
      ~GapProbability ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< variance_type > variance_;
    };

    class StairsProbability: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // variance
      //
      typedef ::xml_schema::decimal variance_type;
      typedef ::xsd::cxx::tree::traits< variance_type, char, ::xsd::cxx::tree::schema_type::decimal > variance_traits;

      const variance_type&
      variance () const;

      variance_type&
      variance ();

      void
      variance (const variance_type& x);

      static variance_type
      variance_default_value ();

      // Constructors.
      //
      StairsProbability (const ::xml_schema::decimal&);

      StairsProbability (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      StairsProbability (const StairsProbability& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual StairsProbability*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      StairsProbability&
      operator= (const StairsProbability& x);

      virtual 
      ~StairsProbability ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< variance_type > variance_;
    };

    class TurnProbability: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // variance
      //
      typedef ::xml_schema::decimal variance_type;
      typedef ::xsd::cxx::tree::traits< variance_type, char, ::xsd::cxx::tree::schema_type::decimal > variance_traits;

      const variance_type&
      variance () const;

      variance_type&
      variance ();

      void
      variance (const variance_type& x);

      static variance_type
      variance_default_value ();

      // Constructors.
      //
      TurnProbability (const ::xml_schema::decimal&);

      TurnProbability (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      TurnProbability (const TurnProbability& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual TurnProbability*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      TurnProbability&
      operator= (const TurnProbability& x);

      virtual 
      ~TurnProbability ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< variance_type > variance_;
    };

    class SizeAndPosition: public ::xml_schema::type
    {
      public:
      // xOrigin
      //
      typedef ::xml_schema::int_ xOrigin_type;
      typedef ::xsd::cxx::tree::traits< xOrigin_type, char > xOrigin_traits;

      const xOrigin_type&
      xOrigin () const;

      xOrigin_type&
      xOrigin ();

      void
      xOrigin (const xOrigin_type& x);

      static xOrigin_type
      xOrigin_default_value ();

      // yOrigin
      //
      typedef ::xml_schema::int_ yOrigin_type;
      typedef ::xsd::cxx::tree::traits< yOrigin_type, char > yOrigin_traits;

      const yOrigin_type&
      yOrigin () const;

      yOrigin_type&
      yOrigin ();

      void
      yOrigin (const yOrigin_type& x);

      static yOrigin_type
      yOrigin_default_value ();

      // zOrigin
      //
      typedef ::xml_schema::int_ zOrigin_type;
      typedef ::xsd::cxx::tree::traits< zOrigin_type, char > zOrigin_traits;

      const zOrigin_type&
      zOrigin () const;

      zOrigin_type&
      zOrigin ();

      void
      zOrigin (const zOrigin_type& x);

      static zOrigin_type
      zOrigin_default_value ();

      // yMin
      //
      typedef ::xml_schema::int_ yMin_type;
      typedef ::xsd::cxx::tree::traits< yMin_type, char > yMin_traits;

      const yMin_type&
      yMin () const;

      yMin_type&
      yMin ();

      void
      yMin (const yMin_type& x);

      static yMin_type
      yMin_default_value ();

      // yMax
      //
      typedef ::xml_schema::int_ yMax_type;
      typedef ::xsd::cxx::tree::traits< yMax_type, char > yMax_traits;

      const yMax_type&
      yMax () const;

      yMax_type&
      yMax ();

      void
      yMax (const yMax_type& x);

      static yMax_type
      yMax_default_value ();

      // Constructors.
      //
      SizeAndPosition ();

      SizeAndPosition (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      SizeAndPosition (const SizeAndPosition& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual SizeAndPosition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SizeAndPosition&
      operator= (const SizeAndPosition& x);

      virtual 
      ~SizeAndPosition ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< xOrigin_type > xOrigin_;
      ::xsd::cxx::tree::one< yOrigin_type > yOrigin_;
      ::xsd::cxx::tree::one< zOrigin_type > zOrigin_;
      ::xsd::cxx::tree::one< yMin_type > yMin_;
      ::xsd::cxx::tree::one< yMax_type > yMax_;
    };

    class SizeAndPosition1: public ::xml_schema::type
    {
      public:
      // width
      //
      typedef ::xml_schema::int_ width_type;
      typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

      const width_type&
      width () const;

      width_type&
      width ();

      void
      width (const width_type& x);

      static width_type
      width_default_value ();

      // length
      //
      typedef ::xml_schema::int_ length_type;
      typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

      const length_type&
      length () const;

      length_type&
      length ();

      void
      length (const length_type& x);

      static length_type
      length_default_value ();

      // height
      //
      typedef ::xml_schema::int_ height_type;
      typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

      const height_type&
      height () const;

      height_type&
      height ();

      void
      height (const height_type& x);

      static height_type
      height_default_value ();

      // scale
      //
      typedef ::xml_schema::int_ scale_type;
      typedef ::xsd::cxx::tree::traits< scale_type, char > scale_traits;

      const scale_type&
      scale () const;

      scale_type&
      scale ();

      void
      scale (const scale_type& x);

      static scale_type
      scale_default_value ();

      // xOrigin
      //
      typedef ::xml_schema::int_ xOrigin_type;
      typedef ::xsd::cxx::tree::traits< xOrigin_type, char > xOrigin_traits;

      const xOrigin_type&
      xOrigin () const;

      xOrigin_type&
      xOrigin ();

      void
      xOrigin (const xOrigin_type& x);

      static xOrigin_type
      xOrigin_default_value ();

      // yOrigin
      //
      typedef ::xml_schema::int_ yOrigin_type;
      typedef ::xsd::cxx::tree::traits< yOrigin_type, char > yOrigin_traits;

      const yOrigin_type&
      yOrigin () const;

      yOrigin_type&
      yOrigin ();

      void
      yOrigin (const yOrigin_type& x);

      static yOrigin_type
      yOrigin_default_value ();

      // zOrigin
      //
      typedef ::xml_schema::int_ zOrigin_type;
      typedef ::xsd::cxx::tree::traits< zOrigin_type, char > zOrigin_traits;

      const zOrigin_type&
      zOrigin () const;

      zOrigin_type&
      zOrigin ();

      void
      zOrigin (const zOrigin_type& x);

      static zOrigin_type
      zOrigin_default_value ();

      // Constructors.
      //
      SizeAndPosition1 ();

      SizeAndPosition1 (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      SizeAndPosition1 (const SizeAndPosition1& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

      virtual SizeAndPosition1*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      SizeAndPosition1&
      operator= (const SizeAndPosition1& x);

      virtual 
      ~SizeAndPosition1 ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< width_type > width_;
      ::xsd::cxx::tree::one< length_type > length_;
      ::xsd::cxx::tree::one< height_type > height_;
      ::xsd::cxx::tree::one< scale_type > scale_;
      ::xsd::cxx::tree::one< xOrigin_type > xOrigin_;
      ::xsd::cxx::tree::one< yOrigin_type > yOrigin_;
      ::xsd::cxx::tree::one< zOrigin_type > zOrigin_;
    };

    class Waypoints: public ::xml_schema::type
    {
      public:
      // WaypointBlock
      //
      typedef ::malmo::schemas::MazeBlock WaypointBlock_type;
      typedef ::xsd::cxx::tree::optional< WaypointBlock_type > WaypointBlock_optional;
      typedef ::xsd::cxx::tree::traits< WaypointBlock_type, char > WaypointBlock_traits;

      const WaypointBlock_optional&
      WaypointBlock () const;

      WaypointBlock_optional&
      WaypointBlock ();

      void
      WaypointBlock (const WaypointBlock_type& x);

      void
      WaypointBlock (const WaypointBlock_optional& x);

      void
      WaypointBlock (::std::auto_ptr< WaypointBlock_type > p);

      // WaypointItem
      //
      typedef ::malmo::schemas::BlockOrItemSpec WaypointItem_type;
      typedef ::xsd::cxx::tree::optional< WaypointItem_type > WaypointItem_optional;
      typedef ::xsd::cxx::tree::traits< WaypointItem_type, char > WaypointItem_traits;

      const WaypointItem_optional&
      WaypointItem () const;

      WaypointItem_optional&
      WaypointItem ();

      void
      WaypointItem (const WaypointItem_type& x);

      void
      WaypointItem (const WaypointItem_optional& x);

      void
      WaypointItem (::std::auto_ptr< WaypointItem_type > p);

      // quantity
      //
      typedef ::xml_schema::int_ quantity_type;
      typedef ::xsd::cxx::tree::traits< quantity_type, char > quantity_traits;

      const quantity_type&
      quantity () const;

      quantity_type&
      quantity ();

      void
      quantity (const quantity_type& x);

      // Constructors.
      //
      Waypoints (const quantity_type&);

      Waypoints (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      Waypoints (const Waypoints& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual Waypoints*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Waypoints&
      operator= (const Waypoints& x);

      virtual 
      ~Waypoints ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      WaypointBlock_optional WaypointBlock_;
      WaypointItem_optional WaypointItem_;
      ::xsd::cxx::tree::one< quantity_type > quantity_;
    };

    class AddQuitProducer: public ::xml_schema::type
    {
      public:
      // description
      //
      typedef ::xml_schema::string description_type;
      typedef ::xsd::cxx::tree::traits< description_type, char > description_traits;

      const description_type&
      description () const;

      description_type&
      description ();

      void
      description (const description_type& x);

      void
      description (::std::auto_ptr< description_type > p);

      static const description_type&
      description_default_value ();

      // Constructors.
      //
      AddQuitProducer ();

      AddQuitProducer (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      AddQuitProducer (const AddQuitProducer& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

      virtual AddQuitProducer*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      AddQuitProducer&
      operator= (const AddQuitProducer& x);

      virtual 
      ~AddQuitProducer ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< description_type > description_;
      static const description_type description_default_value_;
    };

    class AddNavigationObservations: public ::xml_schema::type
    {
      public:
      // Constructors.
      //
      AddNavigationObservations ();

      AddNavigationObservations (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      AddNavigationObservations (const ::xercesc::DOMAttr& a,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      AddNavigationObservations (const ::std::string& s,
                                 const ::xercesc::DOMElement* e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      AddNavigationObservations (const AddNavigationObservations& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

      virtual AddNavigationObservations*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~AddNavigationObservations ();
    };

    class complexity: public ::xml_schema::type
    {
      public:
      // building
      //
      typedef ::malmo::schemas::ZeroToOne building_type;
      typedef ::xsd::cxx::tree::traits< building_type, char > building_traits;

      const building_type&
      building () const;

      building_type&
      building ();

      void
      building (const building_type& x);

      void
      building (::std::auto_ptr< building_type > p);

      // path
      //
      typedef ::malmo::schemas::ZeroToOne path_type;
      typedef ::xsd::cxx::tree::traits< path_type, char > path_traits;

      const path_type&
      path () const;

      path_type&
      path ();

      void
      path (const path_type& x);

      void
      path (::std::auto_ptr< path_type > p);

      // division
      //
      typedef ::malmo::schemas::ZeroToOne division_type;
      typedef ::xsd::cxx::tree::traits< division_type, char > division_traits;

      const division_type&
      division () const;

      division_type&
      division ();

      void
      division (const division_type& x);

      void
      division (::std::auto_ptr< division_type > p);

      // obstacle
      //
      typedef ::malmo::schemas::ZeroToOne obstacle_type;
      typedef ::xsd::cxx::tree::traits< obstacle_type, char > obstacle_traits;

      const obstacle_type&
      obstacle () const;

      obstacle_type&
      obstacle ();

      void
      obstacle (const obstacle_type& x);

      void
      obstacle (::std::auto_ptr< obstacle_type > p);

      // hint
      //
      typedef ::malmo::schemas::ZeroToOne hint_type;
      typedef ::xsd::cxx::tree::traits< hint_type, char > hint_traits;

      const hint_type&
      hint () const;

      hint_type&
      hint ();

      void
      hint (const hint_type& x);

      void
      hint (::std::auto_ptr< hint_type > p);

      // Constructors.
      //
      complexity (const building_type&,
                  const path_type&,
                  const division_type&,
                  const obstacle_type&,
                  const hint_type&);

      complexity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      complexity (const complexity& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual complexity*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      complexity&
      operator= (const complexity& x);

      virtual 
      ~complexity ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< building_type > building_;
      ::xsd::cxx::tree::one< path_type > path_;
      ::xsd::cxx::tree::one< division_type > division_;
      ::xsd::cxx::tree::one< obstacle_type > obstacle_;
      ::xsd::cxx::tree::one< hint_type > hint_;
    };

    class specification: public ::xml_schema::type
    {
      public:
      // width
      //
      typedef ::malmo::schemas::BuildingSize width_type;
      typedef ::xsd::cxx::tree::traits< width_type, char > width_traits;

      const width_type&
      width () const;

      width_type&
      width ();

      void
      width (const width_type& x);

      void
      width (::std::auto_ptr< width_type > p);

      // height
      //
      typedef ::malmo::schemas::BuildingSize height_type;
      typedef ::xsd::cxx::tree::traits< height_type, char > height_traits;

      const height_type&
      height () const;

      height_type&
      height ();

      void
      height (const height_type& x);

      void
      height (::std::auto_ptr< height_type > p);

      // length
      //
      typedef ::malmo::schemas::BuildingSize length_type;
      typedef ::xsd::cxx::tree::traits< length_type, char > length_traits;

      const length_type&
      length () const;

      length_type&
      length ();

      void
      length (const length_type& x);

      void
      length (::std::auto_ptr< length_type > p);

      // pathLength
      //
      typedef ::malmo::schemas::NonNegative pathLength_type;
      typedef ::xsd::cxx::tree::traits< pathLength_type, char > pathLength_traits;

      const pathLength_type&
      pathLength () const;

      pathLength_type&
      pathLength ();

      void
      pathLength (const pathLength_type& x);

      void
      pathLength (::std::auto_ptr< pathLength_type > p);

      // divisions
      //
      typedef ::malmo::schemas::divisions divisions_type;
      typedef ::xsd::cxx::tree::traits< divisions_type, char > divisions_traits;

      const divisions_type&
      divisions () const;

      divisions_type&
      divisions ();

      void
      divisions (const divisions_type& x);

      void
      divisions (::std::auto_ptr< divisions_type > p);

      // horizontalObstacles
      //
      typedef ::malmo::schemas::HorizontalObstacles horizontalObstacles_type;
      typedef ::xsd::cxx::tree::traits< horizontalObstacles_type, char > horizontalObstacles_traits;

      const horizontalObstacles_type&
      horizontalObstacles () const;

      horizontalObstacles_type&
      horizontalObstacles ();

      void
      horizontalObstacles (const horizontalObstacles_type& x);

      void
      horizontalObstacles (::std::auto_ptr< horizontalObstacles_type > p);

      // verticalObstacles
      //
      typedef ::malmo::schemas::VerticalObstacles verticalObstacles_type;
      typedef ::xsd::cxx::tree::traits< verticalObstacles_type, char > verticalObstacles_traits;

      const verticalObstacles_type&
      verticalObstacles () const;

      verticalObstacles_type&
      verticalObstacles ();

      void
      verticalObstacles (const verticalObstacles_type& x);

      void
      verticalObstacles (::std::auto_ptr< verticalObstacles_type > p);

      // hintLikelihood
      //
      typedef ::malmo::schemas::ZeroToOne hintLikelihood_type;
      typedef ::xsd::cxx::tree::traits< hintLikelihood_type, char > hintLikelihood_traits;

      const hintLikelihood_type&
      hintLikelihood () const;

      hintLikelihood_type&
      hintLikelihood ();

      void
      hintLikelihood (const hintLikelihood_type& x);

      void
      hintLikelihood (::std::auto_ptr< hintLikelihood_type > p);

      // Constructors.
      //
      specification (const width_type&,
                     const height_type&,
                     const length_type&,
                     const pathLength_type&,
                     const divisions_type&,
                     const horizontalObstacles_type&,
                     const verticalObstacles_type&,
                     const hintLikelihood_type&);

      specification (const width_type&,
                     const height_type&,
                     const length_type&,
                     const pathLength_type&,
                     ::std::auto_ptr< divisions_type >,
                     ::std::auto_ptr< horizontalObstacles_type >,
                     ::std::auto_ptr< verticalObstacles_type >,
                     const hintLikelihood_type&);

      specification (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      specification (const specification& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

      virtual specification*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      specification&
      operator= (const specification& x);

      virtual 
      ~specification ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< width_type > width_;
      ::xsd::cxx::tree::one< height_type > height_;
      ::xsd::cxx::tree::one< length_type > length_;
      ::xsd::cxx::tree::one< pathLength_type > pathLength_;
      ::xsd::cxx::tree::one< divisions_type > divisions_;
      ::xsd::cxx::tree::one< horizontalObstacles_type > horizontalObstacles_;
      ::xsd::cxx::tree::one< verticalObstacles_type > verticalObstacles_;
      ::xsd::cxx::tree::one< hintLikelihood_type > hintLikelihood_;
    };

    class Parametric: public ::xml_schema::type
    {
      public:
      // x
      //
      typedef ::xml_schema::string x_type;
      typedef ::xsd::cxx::tree::traits< x_type, char > x_traits;

      const x_type&
      x () const;

      x_type&
      x ();

      void
      x (const x_type& x);

      void
      x (::std::auto_ptr< x_type > p);

      // y
      //
      typedef ::xml_schema::string y_type;
      typedef ::xsd::cxx::tree::traits< y_type, char > y_traits;

      const y_type&
      y () const;

      y_type&
      y ();

      void
      y (const y_type& x);

      void
      y (::std::auto_ptr< y_type > p);

      // z
      //
      typedef ::xml_schema::string z_type;
      typedef ::xsd::cxx::tree::traits< z_type, char > z_traits;

      const z_type&
      z () const;

      z_type&
      z ();

      void
      z (const z_type& x);

      void
      z (::std::auto_ptr< z_type > p);

      // seed
      //
      typedef ::malmo::schemas::seed seed_type;
      typedef ::xsd::cxx::tree::optional< seed_type > seed_optional;
      typedef ::xsd::cxx::tree::traits< seed_type, char > seed_traits;

      const seed_optional&
      seed () const;

      seed_optional&
      seed ();

      void
      seed (const seed_type& x);

      void
      seed (const seed_optional& x);

      void
      seed (::std::auto_ptr< seed_type > p);

      // Constructors.
      //
      Parametric (const x_type&,
                  const y_type&,
                  const z_type&);

      Parametric (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      Parametric (const Parametric& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

      virtual Parametric*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Parametric&
      operator= (const Parametric& x);

      virtual 
      ~Parametric ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< x_type > x_;
      ::xsd::cxx::tree::one< y_type > y_;
      ::xsd::cxx::tree::one< z_type > z_;
      seed_optional seed_;
    };

    class Linear: public ::xml_schema::type
    {
      public:
      // CanvasBounds
      //
      typedef ::malmo::schemas::UnnamedGridDefinition CanvasBounds_type;
      typedef ::xsd::cxx::tree::traits< CanvasBounds_type, char > CanvasBounds_traits;

      const CanvasBounds_type&
      CanvasBounds () const;

      CanvasBounds_type&
      CanvasBounds ();

      void
      CanvasBounds (const CanvasBounds_type& x);

      void
      CanvasBounds (::std::auto_ptr< CanvasBounds_type > p);

      // InitialPos
      //
      typedef ::malmo::schemas::Pos InitialPos_type;
      typedef ::xsd::cxx::tree::traits< InitialPos_type, char > InitialPos_traits;

      const InitialPos_type&
      InitialPos () const;

      InitialPos_type&
      InitialPos ();

      void
      InitialPos (const InitialPos_type& x);

      void
      InitialPos (::std::auto_ptr< InitialPos_type > p);

      // InitialVelocity
      //
      typedef ::malmo::schemas::Pos InitialVelocity_type;
      typedef ::xsd::cxx::tree::traits< InitialVelocity_type, char > InitialVelocity_traits;

      const InitialVelocity_type&
      InitialVelocity () const;

      InitialVelocity_type&
      InitialVelocity ();

      void
      InitialVelocity (const InitialVelocity_type& x);

      void
      InitialVelocity (::std::auto_ptr< InitialVelocity_type > p);

      // Constructors.
      //
      Linear (const CanvasBounds_type&,
              const InitialPos_type&,
              const InitialVelocity_type&);

      Linear (::std::auto_ptr< CanvasBounds_type >,
              ::std::auto_ptr< InitialPos_type >,
              ::std::auto_ptr< InitialVelocity_type >);

      Linear (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      Linear (const Linear& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

      virtual Linear*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      Linear&
      operator= (const Linear& x);

      virtual 
      ~Linear ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< CanvasBounds_type > CanvasBounds_;
      ::xsd::cxx::tree::one< InitialPos_type > InitialPos_;
      ::xsd::cxx::tree::one< InitialVelocity_type > InitialVelocity_;
    };

    class DepthScaling: public ::xml_schema::type
    {
      public:
      // min
      //
      typedef ::malmo::schemas::min1 min_type;
      typedef ::xsd::cxx::tree::traits< min_type, char > min_traits;

      const min_type&
      min () const;

      min_type&
      min ();

      void
      min (const min_type& x);

      void
      min (::std::auto_ptr< min_type > p);

      static min_type
      min_default_value ();

      // max
      //
      typedef ::malmo::schemas::max1 max_type;
      typedef ::xsd::cxx::tree::traits< max_type, char > max_traits;

      const max_type&
      max () const;

      max_type&
      max ();

      void
      max (const max_type& x);

      void
      max (::std::auto_ptr< max_type > p);

      static max_type
      max_default_value ();

      // autoscale
      //
      typedef ::xml_schema::boolean autoscale_type;
      typedef ::xsd::cxx::tree::traits< autoscale_type, char > autoscale_traits;

      const autoscale_type&
      autoscale () const;

      autoscale_type&
      autoscale ();

      void
      autoscale (const autoscale_type& x);

      static autoscale_type
      autoscale_default_value ();

      // Constructors.
      //
      DepthScaling ();

      DepthScaling (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      DepthScaling (const DepthScaling& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual DepthScaling*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      DepthScaling&
      operator= (const DepthScaling& x);

      virtual 
      ~DepthScaling ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< min_type > min_;
      ::xsd::cxx::tree::one< max_type > max_;
      ::xsd::cxx::tree::one< autoscale_type > autoscale_;
    };

    class viewpoint: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::int_, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      viewpoint (const ::xml_schema::int_&);

      viewpoint (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      viewpoint (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      viewpoint (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      viewpoint (const viewpoint& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual viewpoint*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~viewpoint ();
    };

    class ModifierList: public ::malmo::schemas::CommandListModifier
    {
      public:
      // Constructors.
      //
      ModifierList ();

      ModifierList (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      ModifierList (const ModifierList& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

      virtual ModifierList*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~ModifierList ();
    };

    class requestedPosition: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >
    {
      public:
      // Constructors.
      //
      requestedPosition (const ::xml_schema::integer&);

      requestedPosition (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      requestedPosition (const ::xercesc::DOMAttr& a,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      requestedPosition (const ::std::string& s,
                         const ::xercesc::DOMElement* e,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      requestedPosition (const requestedPosition& x,
                         ::xml_schema::flags f = 0,
                         ::xml_schema::container* c = 0);

      virtual requestedPosition*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~requestedPosition ();
    };

    class divisions: public ::xml_schema::type
    {
      public:
      // southNorth
      //
      typedef ::malmo::schemas::NonNegative southNorth_type;
      typedef ::xsd::cxx::tree::traits< southNorth_type, char > southNorth_traits;

      const southNorth_type&
      southNorth () const;

      southNorth_type&
      southNorth ();

      void
      southNorth (const southNorth_type& x);

      void
      southNorth (::std::auto_ptr< southNorth_type > p);

      // eastWest
      //
      typedef ::malmo::schemas::NonNegative eastWest_type;
      typedef ::xsd::cxx::tree::traits< eastWest_type, char > eastWest_traits;

      const eastWest_type&
      eastWest () const;

      eastWest_type&
      eastWest ();

      void
      eastWest (const eastWest_type& x);

      void
      eastWest (::std::auto_ptr< eastWest_type > p);

      // aboveBelow
      //
      typedef ::malmo::schemas::NonNegative aboveBelow_type;
      typedef ::xsd::cxx::tree::traits< aboveBelow_type, char > aboveBelow_traits;

      const aboveBelow_type&
      aboveBelow () const;

      aboveBelow_type&
      aboveBelow ();

      void
      aboveBelow (const aboveBelow_type& x);

      void
      aboveBelow (::std::auto_ptr< aboveBelow_type > p);

      // Constructors.
      //
      divisions (const southNorth_type&,
                 const eastWest_type&,
                 const aboveBelow_type&);

      divisions (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      divisions (const divisions& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

      virtual divisions*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      divisions&
      operator= (const divisions& x);

      virtual 
      ~divisions ();

      // Implementation.
      //
      protected:
      void
      parse (::xsd::cxx::xml::dom::parser< char >&,
             ::xml_schema::flags);

      protected:
      ::xsd::cxx::tree::one< southNorth_type > southNorth_;
      ::xsd::cxx::tree::one< eastWest_type > eastWest_;
      ::xsd::cxx::tree::one< aboveBelow_type > aboveBelow_;
    };

    class seed: public ::xml_schema::string
    {
      public:
      // Constructors.
      //
      seed ();

      seed (const char*);

      seed (const ::std::string&);

      seed (const ::xml_schema::string&);

      seed (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      seed (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      seed (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      seed (const seed& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual seed*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~seed ();
    };

    class min1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      min1 (const ::xml_schema::decimal&);

      min1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      min1 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      min1 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      min1 (const min1& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual min1*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~min1 ();
    };

    class max1: public ::xsd::cxx::tree::fundamental_base< ::xml_schema::decimal, char, ::xml_schema::simple_type, ::xsd::cxx::tree::schema_type::decimal >
    {
      public:
      // Constructors.
      //
      max1 (const ::xml_schema::decimal&);

      max1 (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      max1 (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      max1 (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      max1 (const max1& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

      virtual max1*
      _clone (::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0) const;

      virtual 
      ~max1 ();
    };
  }
}

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

namespace malmo
{
  namespace schemas
  {
  }
}

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

namespace malmo
{
  namespace schemas
  {
    void
    operator<< (::xercesc::DOMElement&, const Pos&);

    void
    operator<< (::xercesc::DOMElement&, const PosAndDirection&);

    void
    operator<< (::xercesc::DOMElement&, const BlockList&);

    void
    operator<< (::xercesc::DOMAttr&, const BlockList&);

    void
    operator<< (::xml_schema::list_stream&,
                const BlockList&);

    void
    operator<< (::xercesc::DOMElement&, const ItemList&);

    void
    operator<< (::xercesc::DOMAttr&, const ItemList&);

    void
    operator<< (::xml_schema::list_stream&,
                const ItemList&);

    void
    operator<< (::xercesc::DOMElement&, const BlockOrItemList&);

    void
    operator<< (::xercesc::DOMAttr&, const BlockOrItemList&);

    void
    operator<< (::xml_schema::list_stream&,
                const BlockOrItemList&);

    void
    operator<< (::xercesc::DOMElement&, const ColourList&);

    void
    operator<< (::xercesc::DOMAttr&, const ColourList&);

    void
    operator<< (::xml_schema::list_stream&,
                const ColourList&);

    void
    operator<< (::xercesc::DOMElement&, const VariantList&);

    void
    operator<< (::xercesc::DOMAttr&, const VariantList&);

    void
    operator<< (::xml_schema::list_stream&,
                const VariantList&);

    void
    operator<< (::xercesc::DOMElement&, const MazeBlock&);

    void
    operator<< (::xercesc::DOMElement&, const MazeTerminus&);

    void
    operator<< (::xercesc::DOMElement&, const SnakeBlock&);

    void
    operator<< (::xercesc::DOMElement&, const DrawObjectType&);

    void
    operator<< (::xercesc::DOMAttr&, const DrawObjectType&);

    void
    operator<< (::xml_schema::list_stream&,
                const DrawObjectType&);

    void
    operator<< (::xercesc::DOMElement&, const DrawBlockBasedObjectType&);

    void
    operator<< (::xercesc::DOMElement&, const DrawBlock&);

    void
    operator<< (::xercesc::DOMElement&, const DrawItem&);

    void
    operator<< (::xercesc::DOMElement&, const ContainedObjectType&);

    void
    operator<< (::xercesc::DOMElement&, const DrawContainer&);

    void
    operator<< (::xercesc::DOMElement&, const DrawEntity&);

    void
    operator<< (::xercesc::DOMElement&, const DrawCuboid&);

    void
    operator<< (::xercesc::DOMElement&, const DrawSphere&);

    void
    operator<< (::xercesc::DOMElement&, const DrawLine&);

    void
    operator<< (::xercesc::DOMElement&, const PaletteEnum&);

    void
    operator<< (::xercesc::DOMAttr&, const PaletteEnum&);

    void
    operator<< (::xml_schema::list_stream&,
                const PaletteEnum&);

    void
    operator<< (::xercesc::DOMElement&, const HorizontalObstacles&);

    void
    operator<< (::xercesc::DOMElement&, const VerticalObstacles&);

    void
    operator<< (::xercesc::DOMElement&, const BuildingSize&);

    void
    operator<< (::xercesc::DOMAttr&, const BuildingSize&);

    void
    operator<< (::xml_schema::list_stream&,
                const BuildingSize&);

    void
    operator<< (::xercesc::DOMElement&, const ZeroToOne&);

    void
    operator<< (::xercesc::DOMAttr&, const ZeroToOne&);

    void
    operator<< (::xml_schema::list_stream&,
                const ZeroToOne&);

    void
    operator<< (::xercesc::DOMElement&, const NonNegative&);

    void
    operator<< (::xercesc::DOMAttr&, const NonNegative&);

    void
    operator<< (::xml_schema::list_stream&,
                const NonNegative&);

    void
    operator<< (::xercesc::DOMElement&, const HexColour&);

    void
    operator<< (::xercesc::DOMAttr&, const HexColour&);

    void
    operator<< (::xml_schema::list_stream&,
                const HexColour&);

    void
    operator<< (::xercesc::DOMElement&, const MobWithColour&);

    void
    operator<< (::xercesc::DOMElement&, const ContinuousMovementCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const ContinuousMovementCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const ContinuousMovementCommand&);

    void
    operator<< (::xercesc::DOMElement&, const AbsoluteMovementCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const AbsoluteMovementCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const AbsoluteMovementCommand&);

    void
    operator<< (::xercesc::DOMElement&, const DiscreteMovementCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const DiscreteMovementCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const DiscreteMovementCommand&);

    void
    operator<< (::xercesc::DOMElement&, const InventoryCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const InventoryCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const InventoryCommand&);

    void
    operator<< (::xercesc::DOMElement&, const SimpleCraftCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const SimpleCraftCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const SimpleCraftCommand&);

    void
    operator<< (::xercesc::DOMElement&, const ChatCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const ChatCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const ChatCommand&);

    void
    operator<< (::xercesc::DOMElement&, const MissionQuitCommand&);

    void
    operator<< (::xercesc::DOMAttr&, const MissionQuitCommand&);

    void
    operator<< (::xml_schema::list_stream&,
                const MissionQuitCommand&);

    void
    operator<< (::xercesc::DOMElement&, const Command&);

    void
    operator<< (::xercesc::DOMAttr&, const Command&);

    void
    operator<< (::xml_schema::list_stream&,
                const Command&);

    void
    operator<< (::xercesc::DOMElement&, const CommandList&);

    void
    operator<< (::xercesc::DOMAttr&, const CommandList&);

    void
    operator<< (::xml_schema::list_stream&,
                const CommandList&);

    void
    operator<< (::xercesc::DOMElement&, const CommandListModifier&);

    void
    operator<< (::xercesc::DOMElement&, const NamedPoint&);

    void
    operator<< (::xercesc::DOMElement&, const GridDefinition&);

    void
    operator<< (::xercesc::DOMElement&, const RangeDefinition&);

    void
    operator<< (::xercesc::DOMElement&, const Dimension&);

    void
    operator<< (::xercesc::DOMAttr&, const Dimension&);

    void
    operator<< (::xml_schema::list_stream&,
                const Dimension&);

    void
    operator<< (::xercesc::DOMElement&, const PointWithReward&);

    void
    operator<< (::xercesc::DOMElement&, const MobWithReward&);

    void
    operator<< (::xercesc::DOMElement&, const BlockSpec&);

    void
    operator<< (::xercesc::DOMElement&, const BlockOrItemSpec&);

    void
    operator<< (::xercesc::DOMElement&, const BlockSpecWithRewardAndBehaviour&);

    void
    operator<< (::xercesc::DOMElement&, const BlockOrItemSpecWithReward&);

    void
    operator<< (::xercesc::DOMElement&, const Behaviour&);

    void
    operator<< (::xercesc::DOMAttr&, const Behaviour&);

    void
    operator<< (::xml_schema::list_stream&,
                const Behaviour&);

    void
    operator<< (::xercesc::DOMElement&, const ChatMatchSpec&);

    void
    operator<< (::xercesc::DOMElement&, const ItemSpec&);

    void
    operator<< (::xercesc::DOMElement&, const MissionEndRewardCase&);

    void
    operator<< (::xercesc::DOMElement&, const RewardDensityForBuildAndBreak&);

    void
    operator<< (::xercesc::DOMAttr&, const RewardDensityForBuildAndBreak&);

    void
    operator<< (::xml_schema::list_stream&,
                const RewardDensityForBuildAndBreak&);

    void
    operator<< (::xercesc::DOMElement&, const UnnamedGridDefinition&);

    void
    operator<< (::xercesc::DOMElement&, const RewardDensityForTimeTaken&);

    void
    operator<< (::xercesc::DOMAttr&, const RewardDensityForTimeTaken&);

    void
    operator<< (::xml_schema::list_stream&,
                const RewardDensityForTimeTaken&);

    void
    operator<< (::xercesc::DOMElement&, const MobWithDescription&);

    void
    operator<< (::xercesc::DOMElement&, const MobWithDescriptionAndReward&);

    void
    operator<< (::xercesc::DOMElement&, const PointWithToleranceAndDescription&);

    void
    operator<< (::xercesc::DOMElement&, const BlockSpecWithDescription&);

    void
    operator<< (::xercesc::DOMElement&, const BlockOrItemSpecWithDescription&);

    void
    operator<< (::xercesc::DOMElement&, const MobList&);

    void
    operator<< (::xercesc::DOMAttr&, const MobList&);

    void
    operator<< (::xml_schema::list_stream&,
                const MobList&);

    void
    operator<< (::xercesc::DOMElement&, const CommandQuota&);

    void
    operator<< (::xercesc::DOMElement&, const yaw&);

    void
    operator<< (::xercesc::DOMAttr&, const yaw&);

    void
    operator<< (::xml_schema::list_stream&,
                const yaw&);

    void
    operator<< (::xercesc::DOMElement&, const pitch&);

    void
    operator<< (::xercesc::DOMAttr&, const pitch&);

    void
    operator<< (::xml_schema::list_stream&,
                const pitch&);

    void
    operator<< (::xercesc::DOMElement&, const FlatWorldGenerator&);

    void
    operator<< (::xercesc::DOMElement&, const DefaultWorldGenerator&);

    void
    operator<< (::xercesc::DOMElement&, const FileWorldGenerator&);

    void
    operator<< (::xercesc::DOMElement&, const MovingTargetDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const SnakeDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const MazeDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const DrawingDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const ClassroomDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const AnimationDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const BuildBattleDecorator&);

    void
    operator<< (::xercesc::DOMElement&, const ServerQuitFromTimeUp&);

    void
    operator<< (::xercesc::DOMElement&, const ServerQuitWhenAnyAgentFinishes&);

    void
    operator<< (::xercesc::DOMElement&, const DepthProducer&);

    void
    operator<< (::xercesc::DOMElement&, const LuminanceProducer&);

    void
    operator<< (::xercesc::DOMElement&, const ColourMapProducer&);

    void
    operator<< (::xercesc::DOMElement&, const VideoProducer&);

    void
    operator<< (::xercesc::DOMElement&, const type&);

    void
    operator<< (::xercesc::DOMAttr&, const type&);

    void
    operator<< (::xml_schema::list_stream&,
                const type&);

    void
    operator<< (::xercesc::DOMElement&, const ContinuousMovementCommands&);

    void
    operator<< (::xercesc::DOMElement&, const AbsoluteMovementCommands&);

    void
    operator<< (::xercesc::DOMElement&, const DiscreteMovementCommands&);

    void
    operator<< (::xercesc::DOMElement&, const InventoryCommands&);

    void
    operator<< (::xercesc::DOMElement&, const SimpleCraftCommands&);

    void
    operator<< (::xercesc::DOMElement&, const ChatCommands&);

    void
    operator<< (::xercesc::DOMElement&, const MissionQuitCommands&);

    void
    operator<< (::xercesc::DOMElement&, const TurnBasedCommands&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromRecentCommands&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromRecentCommands&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromRecentCommands&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromTurnScheduler&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromTurnScheduler&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromTurnScheduler&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromSubgoalPositionList&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromHotBar&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromHotBar&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromHotBar&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromFullStats&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromFullStats&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromFullStats&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromRay&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromRay&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromRay&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromFullInventory&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromDiscreteCell&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromDiscreteCell&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromDiscreteCell&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromDistance&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromGrid&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromNearbyEntities&);

    void
    operator<< (::xercesc::DOMElement&, const ObservationFromChat&);

    void
    operator<< (::xercesc::DOMAttr&, const ObservationFromChat&);

    void
    operator<< (::xml_schema::list_stream&,
                const ObservationFromChat&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForDamagingEntity&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForReachingPosition&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForTouchingBlockType&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForSendingCommand&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForSendingMatchingChatMessage&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForCollectingItem&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForDiscardingItem&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForMissionEnd&);

    void
    operator<< (::xercesc::DOMElement&, const min&);

    void
    operator<< (::xercesc::DOMElement&, const max&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForStructureCopying&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForTimeTaken&);

    void
    operator<< (::xercesc::DOMElement&, const RewardForCatchingMob&);

    void
    operator<< (::xercesc::DOMElement&, const AgentQuitFromReachingPosition&);

    void
    operator<< (::xercesc::DOMElement&, const AgentQuitFromTimeUp&);

    void
    operator<< (::xercesc::DOMElement&, const AgentQuitFromTouchingBlockType&);

    void
    operator<< (::xercesc::DOMElement&, const AgentQuitFromCollectingItem&);

    void
    operator<< (::xercesc::DOMElement&, const AgentQuitFromCatchingMob&);

    void
    operator<< (::xercesc::DOMElement&, const AgentQuitFromReachingCommandQuota&);

    void
    operator<< (::xercesc::DOMElement&, const Seed&);

    void
    operator<< (::xercesc::DOMAttr&, const Seed&);

    void
    operator<< (::xml_schema::list_stream&,
                const Seed&);

    void
    operator<< (::xercesc::DOMElement&, const UpdateSpeed&);

    void
    operator<< (::xercesc::DOMAttr&, const UpdateSpeed&);

    void
    operator<< (::xml_schema::list_stream&,
                const UpdateSpeed&);

    void
    operator<< (::xercesc::DOMElement&, const MaterialSeed&);

    void
    operator<< (::xercesc::DOMAttr&, const MaterialSeed&);

    void
    operator<< (::xml_schema::list_stream&,
                const MaterialSeed&);

    void
    operator<< (::xercesc::DOMElement&, const GapProbability&);

    void
    operator<< (::xercesc::DOMElement&, const StairsProbability&);

    void
    operator<< (::xercesc::DOMElement&, const TurnProbability&);

    void
    operator<< (::xercesc::DOMElement&, const SizeAndPosition&);

    void
    operator<< (::xercesc::DOMElement&, const SizeAndPosition1&);

    void
    operator<< (::xercesc::DOMElement&, const Waypoints&);

    void
    operator<< (::xercesc::DOMElement&, const AddQuitProducer&);

    void
    operator<< (::xercesc::DOMElement&, const AddNavigationObservations&);

    void
    operator<< (::xercesc::DOMAttr&, const AddNavigationObservations&);

    void
    operator<< (::xml_schema::list_stream&,
                const AddNavigationObservations&);

    void
    operator<< (::xercesc::DOMElement&, const complexity&);

    void
    operator<< (::xercesc::DOMElement&, const specification&);

    void
    operator<< (::xercesc::DOMElement&, const Parametric&);

    void
    operator<< (::xercesc::DOMElement&, const Linear&);

    void
    operator<< (::xercesc::DOMElement&, const DepthScaling&);

    void
    operator<< (::xercesc::DOMElement&, const viewpoint&);

    void
    operator<< (::xercesc::DOMAttr&, const viewpoint&);

    void
    operator<< (::xml_schema::list_stream&,
                const viewpoint&);

    void
    operator<< (::xercesc::DOMElement&, const ModifierList&);

    void
    operator<< (::xercesc::DOMElement&, const requestedPosition&);

    void
    operator<< (::xercesc::DOMAttr&, const requestedPosition&);

    void
    operator<< (::xml_schema::list_stream&,
                const requestedPosition&);

    void
    operator<< (::xercesc::DOMElement&, const divisions&);

    void
    operator<< (::xercesc::DOMElement&, const seed&);

    void
    operator<< (::xercesc::DOMAttr&, const seed&);

    void
    operator<< (::xml_schema::list_stream&,
                const seed&);

    void
    operator<< (::xercesc::DOMElement&, const min1&);

    void
    operator<< (::xercesc::DOMAttr&, const min1&);

    void
    operator<< (::xml_schema::list_stream&,
                const min1&);

    void
    operator<< (::xercesc::DOMElement&, const max1&);

    void
    operator<< (::xercesc::DOMAttr&, const max1&);

    void
    operator<< (::xml_schema::list_stream&,
                const max1&);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CXX_HOME_DAVEY_MALMO_PLATFORM_PY2_SCHEMAS_MISSION_HANDLERS_H
